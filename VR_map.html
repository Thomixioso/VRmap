<!DOCTYPE html>
<html lang="cs">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VR ≈Ωiv√° Mapa Svƒõta - Meta Quest 3</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #000;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
        }
        
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            z-index: 100;
            background: rgba(0,0,0,0.9);
            padding: 15px;
            border-radius: 8px;
            max-width: 350px;
            backdrop-filter: blur(10px);
        }
        
        #vrButton {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 100;
        }
        
        #controls {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 100;
            background: rgba(0,0,0,0.9);
            padding: 15px;
            border-radius: 8px;
            color: white;
            min-width: 250px;
            backdrop-filter: blur(10px);
        }
        
        .back-button {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 101;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            text-decoration: none;
            padding: 12px 24px;
            border-radius: 25px;
            font-weight: 500;
            transition: all 0.3s ease;
            border: 1px solid rgba(255, 255, 255, 0.3);
        }
        
        .back-button:hover {
            background: rgba(255, 255, 255, 0.1);
            transform: translateX(-50%) translateY(-2px);
        }
        
        canvas {
            display: block;
        }
        
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 18px;
            text-align: center;
        }
        
        button {
            background: linear-gradient(135deg, #4a90e2, #357abd);
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 6px;
            cursor: pointer;
            margin: 3px;
            font-size: 12px;
            transition: all 0.3s ease;
        }
        
        button:hover {
            background: linear-gradient(135deg, #357abd, #2c5aa0);
            transform: translateY(-1px);
        }
        
        select {
            background: #333;
            color: white;
            border: 1px solid #555;
            padding: 5px;
            border-radius: 4px;
            width: 100%;
            margin: 5px 0;
        }
        
        .vr-hint {
            background: rgba(74, 144, 226, 0.2);
            border: 1px solid rgba(74, 144, 226, 0.5);
            padding: 10px;
            border-radius: 6px;
            margin-top: 10px;
            font-size: 11px;
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-button">‚Üê Zpƒõt na v√Ωbƒõr</a>
    
    <div id="info">
        <h3>üåç VR ≈Ωiv√° Mapa Svƒõta</h3>
        <p><strong>Desktop:</strong> WASD pohyb, Q/E zoom</p>
        <p><strong>VR Ovl√°d√°n√≠:</strong></p>
        <ul style="font-size: 12px; margin: 5px 0; padding-left: 15px;">
            <li><strong>Joystick L:</strong> Posun mapy</li>
            <li><strong>Joystick R:</strong> Zoom in/out</li>
            <li><strong>Trigger:</strong> P≈ôidat marker</li>
            <li><strong>Grip:</strong> Rychl√Ω posun</li>
        </ul>
        <div id="coords">GPS: 49.75, 15.5</div>
        <div id="zoomInfo">Zoom: 4 | Tiles: 0</div>
        <div id="status">Inicializuji...</div>
    </div>
    
    <div id="controls">
        <h4>üéÆ Nastaven√≠</h4>
        <div>
            <label>Mapov√Ω styl:</label>
            <select id="mapStyle">
                <option value="osm">üó∫Ô∏è OpenStreetMap</option>
                <option value="satellite">üõ∞Ô∏è Satellite</option>
                <option value="terrain">üèîÔ∏è Terrain</option>
                <option value="toner">‚ö´ Toner B&W</option>
            </select>
        </div>
        <div style="margin-top: 10px;">
            <button onclick="jumpToLocation('prague')">üèõÔ∏è Praha</button>
            <button onclick="jumpToLocation('london')">üá¨üáß Lond√Ωn</button>
            <button onclick="jumpToLocation('nyc')">üóΩ NYC</button>
            <button onclick="jumpToLocation('tokyo')">üóæ Tokio</button>
        </div>
        <div style="margin-top: 10px;">
            <button onclick="clearMarkers()">üóëÔ∏è Sma≈æ markery</button>
            <button onclick="toggleWireframe()">üìê Wireframe</button>
        </div>
        
        <div class="vr-hint">
            <strong>üí° VR Tip:</strong> Pou≈æ√≠vejte joystiky pro plynulou navigaci po cel√©m svƒõtƒõ!
        </div>
    </div>
    
    <div class="loading" id="loading">üöÄ Naƒç√≠t√°m ≈æivou mapu svƒõta...</div>
    <div id="vrButton"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script type="module">
        import { VRButton } from 'https://cdn.skypack.dev/three@0.128.0/examples/jsm/webxr/VRButton.js';
        import { XRControllerModelFactory } from 'https://cdn.skypack.dev/three@0.128.0/examples/jsm/webxr/XRControllerModelFactory.js';
        
        // === KONFIGURACE ===
        const WORLD_SIZE = 200;
        const TILE_SIZE = 256;
        const MIN_ZOOM = 1;
        const MAX_ZOOM = 18;
        
        // === Z√ÅKLADN√ç SETUP ===
        let scene, camera, renderer, mapGroup, tilesGroup;
        let controller1, controller2, controllerGrip1, controllerGrip2;
        let raycaster, mouse = new THREE.Vector2();
        let markers = [];
        
        // === MAPA STAV ===
        let currentZoom = 4;
        let mapCenter = { lat: 49.75, lng: 15.5 }; // Praha
        let currentTiles = new Map();
        let loadingTiles = new Set();
        let mapStyle = 'osm';
        let isWireframe = false;
        
        // === VR OVL√ÅD√ÅN√ç ===
        let vrMovement = { x: 0, z: 0, zoom: 0 };
        let lastControllerPositions = new Map();
        
        // === TILE SERVERY ===
        const tileServers = {
            osm: 'https://tile.openstreetmap.org/{z}/{x}/{y}.png',
            satellite: 'https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}',
            terrain: 'https://stamen-tiles.a.ssl.fastly.net/terrain/{z}/{x}/{y}.png',
            toner: 'https://stamen-tiles.a.ssl.fastly.net/toner/{z}/{x}/{y}.png'
        };
        
        // === INICIALIZACE ===
        function init() {
            console.log('üöÄ Inicializuji VR ≈æivou mapu...');
            
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            
            // Camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 15, 15);
            camera.lookAt(0, 0, 0);
            
            // Renderer s WebXR
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.xr.enabled = true;
            document.body.appendChild(renderer.domElement);
            
            // VR Button
            document.getElementById('vrButton').appendChild(VRButton.createButton(renderer));
            
            setupLighting();
            createMapStructure();
            setupVRControllers();
            setupInteractions();
            loadVisibleTiles();
            
            // Animation loop
            renderer.setAnimationLoop(animate);
            
            document.getElementById('loading').style.display = 'none';
            updateStatus('‚úÖ ≈Ωiv√° mapa p≈ôipravena!');
        }
        
        // === OSVƒöTLEN√ç ===
        function setupLighting() {
            const ambientLight = new THREE.AmbientLight(0x404040, 0.8);
            scene.add(ambientLight);
            
            const sunLight = new THREE.DirectionalLight(0xffffff, 1.0);
            sunLight.position.set(100, 100, 50);
            sunLight.castShadow = true;
            sunLight.shadow.mapSize.width = 2048;
            sunLight.shadow.mapSize.height = 2048;
            scene.add(sunLight);
            
            scene.fog = new THREE.Fog(0x87CEEB, 100, 400);
        }
        
        // === STRUKTURA MAPY ===
        function createMapStructure() {
            mapGroup = new THREE.Group();
            scene.add(mapGroup);
            
            tilesGroup = new THREE.Group();
            mapGroup.add(tilesGroup);
            
            // Z√°kladn√≠ podklad
            const baseGeometry = new THREE.PlaneGeometry(WORLD_SIZE, WORLD_SIZE);
            const baseMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x4A90E2,
                transparent: true,
                opacity: 0.3
            });
            
            const basePlane = new THREE.Mesh(baseGeometry, baseMaterial);
            basePlane.rotation.x = -Math.PI / 2;
            basePlane.position.y = -0.1;
            mapGroup.add(basePlane);
        }
        
        // === NAƒå√çT√ÅN√ç TILES ===
        function loadVisibleTiles() {
            const tilesInView = getVisibleTiles();
            let loadedCount = 0;
            
            tilesInView.forEach(tileCoord => {
                const tileKey = `${tileCoord.z}-${tileCoord.x}-${tileCoord.y}`;
                
                if (!currentTiles.has(tileKey) && !loadingTiles.has(tileKey)) {
                    loadingTiles.add(tileKey);
                    loadTile(tileCoord.x, tileCoord.y, tileCoord.z)
                        .then(() => {
                            loadedCount++;
                            loadingTiles.delete(tileKey);
                        })
                        .catch(() => loadingTiles.delete(tileKey));
                }
            });
            
            // Cleanup star√Ωch tiles
            currentTiles.forEach((tile, key) => {
                const isVisible = tilesInView.some(coord => 
                    key === `${coord.z}-${coord.x}-${coord.y}`
                );
                if (!isVisible) {
                    tilesGroup.remove(tile);
                    currentTiles.delete(key);
                }
            });
            
            updateInfo();
        }
        
        function getVisibleTiles() {
            const tiles = [];
            const zoomLevel = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, Math.round(currentZoom)));
            
            // V√Ωpoƒçet tile sou≈ôadnic podle zoom a pozice
            const tileCount = Math.pow(2, zoomLevel);
            const centerTileX = Math.floor((mapCenter.lng + 180) / 360 * tileCount);
            const centerTileY = Math.floor((1 - Math.log(Math.tan(mapCenter.lat * Math.PI / 180) + 1 / Math.cos(mapCenter.lat * Math.PI / 180)) / Math.PI) / 2 * tileCount);
            
            // Naƒçti okoln√≠ tiles
            const tileRadius = Math.ceil(3 + (10 - zoomLevel) * 0.5);
            
            for (let dx = -tileRadius; dx <= tileRadius; dx++) {
                for (let dy = -tileRadius; dy <= tileRadius; dy++) {
                    const tileX = centerTileX + dx;
                    const tileY = centerTileY + dy;
                    
                    if (tileX >= 0 && tileX < tileCount && tileY >= 0 && tileY < tileCount) {
                        tiles.push({ x: tileX, y: tileY, z: zoomLevel });
                    }
                }
            }
            
            return tiles;
        }
        
        async function loadTile(x, y, z) {
            const tileKey = `${z}-${x}-${y}`;
            const url = tileServers[mapStyle]
                .replace('{x}', x)
                .replace('{y}', y)
                .replace('{z}', z);
            
            return new Promise((resolve, reject) => {
                const loader = new THREE.TextureLoader();
                loader.setCrossOrigin('anonymous');
                
                loader.load(
                    url,
                    (texture) => {
                        const tileSize = WORLD_SIZE / Math.pow(2, z - currentZoom + 2);
                        
                        // V√Ωpoƒçet pozice tile
                        const tileCount = Math.pow(2, z);
                        const worldX = (x / tileCount - 0.5) * WORLD_SIZE * Math.pow(2, z - currentZoom);
                        const worldZ = -(y / tileCount - 0.5) * WORLD_SIZE * Math.pow(2, z - currentZoom);
                        
                        // Vytvo≈ôen√≠ tile meshe
                        const geometry = new THREE.PlaneGeometry(tileSize, tileSize);
                        const material = new THREE.MeshBasicMaterial({ 
                            map: texture,
                            transparent: true,
                            wireframe: isWireframe
                        });
                        
                        const tileMesh = new THREE.Mesh(geometry, material);
                        tileMesh.rotation.x = -Math.PI / 2;
                        tileMesh.position.set(worldX, 0, worldZ);
                        tileMesh.userData = { tileKey, x, y, z };
                        
                        tilesGroup.add(tileMesh);
                        currentTiles.set(tileKey, tileMesh);
                        
                        resolve();
                    },
                    undefined,
                    reject
                );
            });
        }
        
        // === VR OVLADAƒåE ===
        function setupVRControllers() {
            console.log('üéÆ Nastavuji VR ovladaƒçe...');
            
            const controllerModelFactory = new XRControllerModelFactory();
            raycaster = new THREE.Raycaster();
            
            // Controller 1 (prav√Ω)
            controller1 = renderer.xr.getController(0);
            controller1.addEventListener('selectstart', onSelectStart);
            controller1.addEventListener('selectend', onSelectEnd);
            scene.add(controller1);
            
            controllerGrip1 = renderer.xr.getControllerGrip(0);
            controllerGrip1.add(controllerModelFactory.createControllerModel(controllerGrip1));
            scene.add(controllerGrip1);
            
            // Controller 2 (lev√Ω)
            controller2 = renderer.xr.getController(1);
            controller2.addEventListener('selectstart', onSelectStart);
            controller2.addEventListener('selectend', onSelectEnd);
            scene.add(controller2);
            
            controllerGrip2 = renderer.xr.getControllerGrip(1);
            controllerGrip2.add(controllerModelFactory.createControllerModel(controllerGrip2));
            scene.add(controllerGrip2);
            
            // Lasery z ovladaƒç≈Ø
            addControllerLine(controller1);
            addControllerLine(controller2);
        }
        
        function addControllerLine(controller) {
            const geometry = new THREE.BufferGeometry().setFromPoints([
                new THREE.Vector3(0, 0, 0),
                new THREE.Vector3(0, 0, -1)
            ]);
            
            const line = new THREE.Line(geometry, new THREE.LineBasicMaterial({ color: 0x00ff00 }));
            line.name = 'line';
            line.scale.z = 20;
            controller.add(line);
        }
        
        // === VR INTERAKCE ===
        function updateVRInput() {
            if (!renderer.xr.isPresenting) return;
            
            const session = renderer.xr.getSession();
            if (!session) return;
            
            for (let i = 0; i < 2; i++) {
                const inputSource = session.inputSources[i];
                if (inputSource && inputSource.gamepad) {
                    const gamepad = inputSource.gamepad;
                    
                    if (i === 0) { // Lev√Ω ovladaƒç - posun mapy
                        if (gamepad.axes.length >= 2) {
                            const joystickX = gamepad.axes[2] || 0; // thumbstick x
                            const joystickY = gamepad.axes[3] || 0; // thumbstick y
                            
                            // Posun mapy
                            const moveSpeed = 0.001 * Math.pow(2, currentZoom - 4);
                            mapCenter.lng += joystickX * moveSpeed * 50;
                            mapCenter.lat -= joystickY * moveSpeed * 50;
                            
                            // Omez rozsah
                            mapCenter.lat = Math.max(-85, Math.min(85, mapCenter.lat));
                            mapCenter.lng = ((mapCenter.lng + 180) % 360) - 180;
                        }
                    }
                    
                    if (i === 1) { // Prav√Ω ovladaƒç - zoom
                        if (gamepad.axes.length >= 4) {
                            const joystickY = gamepad.axes[3] || 0;
                            
                            // Zoom
                            if (Math.abs(joystickY) > 0.1) {
                                currentZoom += joystickY * 0.02;
                                currentZoom = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, currentZoom));
                            }
                        }
                    }
                    
                    // Grip buttony pro rychl√Ω posun
                    if (gamepad.buttons[1] && gamepad.buttons[1].pressed) {
                        const controller = i === 0 ? controller1 : controller2;
                        handleGripMovement(controller, i);
                    }
                }
            }
        }
        
        function handleGripMovement(controller, controllerIndex) {
            const currentPos = controller.position.clone();
            const lastPos = lastControllerPositions.get(controllerIndex);
            
            if (lastPos) {
                const delta = currentPos.clone().sub(lastPos);
                
                // P≈ôevod VR pohybu na posun mapy
                const moveScale = 0.01 * Math.pow(2, currentZoom - 4);
                mapCenter.lng -= delta.x * moveScale * 10;
                mapCenter.lat += delta.z * moveScale * 10;
                
                // Omez rozsah
                mapCenter.lat = Math.max(-85, Math.min(85, mapCenter.lat));
                mapCenter.lng = ((mapCenter.lng + 180) % 360) - 180;
            }
            
            lastControllerPositions.set(controllerIndex, currentPos);
        }
        
        // === DESKTOP OVL√ÅD√ÅN√ç ===
        function setupInteractions() {
            setupDesktopControls();
            
            // Map style selector
            document.getElementById('mapStyle').addEventListener('change', (e) => {
                mapStyle = e.target.value;
                clearCurrentTiles();
                loadVisibleTiles();
                updateStatus(`üé® Styl zmƒõnƒõn na: ${e.target.options[e.target.selectedIndex].text}`);
            });
            
            // Click events
            renderer.domElement.addEventListener('click', onMapClick);
        }
        
        function setupDesktopControls() {
            const keys = {};
            
            document.addEventListener('keydown', (e) => keys[e.key.toLowerCase()] = true);
            document.addEventListener('keyup', (e) => keys[e.key.toLowerCase()] = false);
            
            function updateDesktopMovement() {
                const moveSpeed = 0.02 * Math.pow(2, currentZoom - 4);
                
                if (keys['w']) mapCenter.lat += moveSpeed;
                if (keys['s']) mapCenter.lat -= moveSpeed;
                if (keys['a']) mapCenter.lng -= moveSpeed;
                if (keys['d']) mapCenter.lng += moveSpeed;
                if (keys['q']) currentZoom = Math.min(MAX_ZOOM, currentZoom + 0.1);
                if (keys['e']) currentZoom = Math.max(MIN_ZOOM, currentZoom - 0.1);
                
                // Omez rozsah
                mapCenter.lat = Math.max(-85, Math.min(85, mapCenter.lat));
                mapCenter.lng = ((mapCenter.lng + 180) % 360) - 180;
                
                requestAnimationFrame(updateDesktopMovement);
            }
            updateDesktopMovement();
            
            // Mouse wheel zoom
            renderer.domElement.addEventListener('wheel', (e) => {
                e.preventDefault();
                const zoomChange = -e.deltaY * 0.001;
                currentZoom = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, currentZoom + zoomChange));
            });
        }
        
        // === EVENTS ===
        function onSelectStart(event) {
            const controller = event.target;
            const intersections = getIntersections(controller);
            
            if (intersections.length > 0) {
                const intersection = intersections[0];
                const worldPos = intersection.point;
                const gps = worldToGPS(worldPos);
                
                addMarker(gps.lat, gps.lng, `Marker ${markers.length + 1}`);
                updateGPSDisplay(gps.lat, gps.lng);
                
                // Haptic feedback
                if (controller.gamepad && controller.gamepad.hapticActuators) {
                    controller.gamepad.hapticActuators[0].pulse(0.8, 200);
                }
            }
        }
        
        function onSelectEnd(event) {}
        
        function getIntersections(controller) {
            const tempMatrix = new THREE.Matrix4();
            tempMatrix.identity().extractRotation(controller.matrixWorld);
            
            raycaster.ray.origin.setFromMatrixPosition(controller.matrixWorld);
            raycaster.ray.direction.set(0, 0, -1).applyMatrix4(tempMatrix);
            
            const intersectables = [...currentTiles.values(), ...markers];
            return raycaster.intersectObjects(intersectables);
        }
        
        function onMapClick(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects([...currentTiles.values()]);
            
            if (intersects.length > 0) {
                const worldPos = intersects[0].point;
                const gps = worldToGPS(worldPos);
                addMarker(gps.lat, gps.lng, `Marker ${markers.length + 1}`);
                updateGPSDisplay(gps.lat, gps.lng);
            }
        }
        
        // === MARKERY ===
        function addMarker(lat, lng, label, color = 0xff0000) {
            const worldPos = gpsToWorld(lat, lng);
            
            const geometry = new THREE.ConeGeometry(2, 6, 8);
            const material = new THREE.MeshLambertMaterial({ color: color });
            const marker = new THREE.Mesh(geometry, material);
            
            marker.position.set(worldPos.x, 3, worldPos.z);
            marker.castShadow = true;
            marker.userData = { label, lat, lng };
            
            scene.add(marker);
            markers.push(marker);
            
            updateStatus(`üìç Marker p≈ôid√°n: ${lat.toFixed(4)}, ${lng.toFixed(4)}`);
        }
        
        // === KOORDIN√ÅTY ===
        function gpsToWorld(lat, lng) {
            const scale = WORLD_SIZE / 360;
            const x = lng * scale;
            const z = -lat * scale; // Z√°porn√© Z pro spr√°vnou orientaci
            return { x, z };
        }
        
        function worldToGPS(worldPos) {
            const scale = 360 / WORLD_SIZE;
            const lng = worldPos.x * scale;
            const lat = -worldPos.z * scale;
            return { lat, lng };
        }
        
        // === UTILITY FUNKCE ===
        function clearCurrentTiles() {
            currentTiles.forEach(tile => tilesGroup.remove(tile));
            currentTiles.clear();
            loadingTiles.clear();
        }
        
        function clearMarkers() {
            markers.forEach(marker => scene.remove(marker));
            markers = [];
            updateStatus('üóëÔ∏è V≈°echny markery smaz√°ny');
        }
        
        function toggleWireframe() {
            isWireframe = !isWireframe;
            currentTiles.forEach(tile => {
                tile.material.wireframe = isWireframe;
            });
            updateStatus(`üìê Wireframe: ${isWireframe ? 'ZAP' : 'VYP'}`);
        }
        
        function jumpToLocation(location) {
            const locations = {
                prague: { lat: 50.0755, lng: 14.4378, zoom: 12 },
                london: { lat: 51.5074, lng: -0.1278, zoom: 12 },
                nyc: { lat: 40.7128, lng: -74.0060, zoom: 12 },
                tokyo: { lat: 35.6762, lng: 139.6503, zoom: 12 }
            };
            
            const loc = locations[location];
            if (loc) {
                mapCenter.lat = loc.lat;
                mapCenter.lng = loc.lng;
                currentZoom = loc.zoom;
                clearCurrentTiles();
                loadVisibleTiles();
                updateStatus(`‚úàÔ∏è Skok na: ${location.toUpperCase()}`);
            }
        }
        
        function updateGPSDisplay(lat = mapCenter.lat, lng = mapCenter.lng) {
            document.getElementById('coords').textContent = `GPS: ${lat.toFixed(4)}, ${lng.toFixed(4)}`;
        }
        
        function updateInfo() {
            document.getElementById('zoomInfo').textContent = 
                `Zoom: ${currentZoom.toFixed(1)} | Tiles: ${currentTiles.size}`;
        }
        
        function updateStatus(message) {
            document.getElementById('status').textContent = message;
            console.log(message);
        }
        
        // === ANIMATION LOOP ===
        function animate() {
            updateVRInput();
            
            // Periodick√© naƒç√≠t√°n√≠ tiles
            if (Math.random() < 0.1) { // 10% chance ka≈æd√Ω frame
                loadVisibleTiles();
            }
            
            // Animace marker≈Ø
            markers.forEach((marker, i) => {
                marker.rotation.y += 0.02;
                marker.position.y = 3 + Math.sin(Date.now() * 0.003 + i) * 0.5;
            });
            
            updateGPSDisplay();
            updateInfo();
            
            renderer.render(scene, camera);
        }
        
        // === RESIZE ===
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        // === GLOB√ÅLN√ç FUNKCE ===
        window.jumpToLocation = jumpToLocation;
        window.clearMarkers = clearMarkers;
        window.toggleWireframe = toggleWireframe;
        
        // === START ===
        init();
        console.log('üåç VR ≈æiv√° mapa svƒõta p≈ôipravena!');
        
    </script>
</body>
</html>
