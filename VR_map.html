<!DOCTYPE html>
<html lang="cs">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VR ≈Ωiv√° Mapa - Funkƒçn√≠ verze</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #000;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
        }
        
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            z-index: 100;
            background: rgba(0,0,0,0.9);
            padding: 15px;
            border-radius: 8px;
            max-width: 350px;
        }
        
        #vrButton {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 100;
        }
        
        #controls {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 100;
            background: rgba(0,0,0,0.9);
            padding: 15px;
            border-radius: 8px;
            color: white;
            min-width: 200px;
        }
        
        .back-button {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 101;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            text-decoration: none;
            padding: 12px 24px;
            border-radius: 25px;
            font-weight: 500;
            transition: all 0.3s ease;
            border: 1px solid rgba(255, 255, 255, 0.3);
        }
        
        .back-button:hover {
            background: rgba(255, 255, 255, 0.1);
            transform: translateX(-50%) translateY(-2px);
        }
        
        canvas {
            display: block;
        }
        
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 18px;
            text-align: center;
        }
        
        button {
            background: #4a90e2;
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            margin: 3px;
            font-size: 12px;
        }
        
        button:hover {
            background: #357abd;
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-button">‚Üê Zpƒõt na v√Ωbƒõr</a>
    
    <div id="info">
        <h3>üåç VR ≈Ωiv√° Mapa</h3>
        <p><strong>Desktop:</strong></p>
        <ul style="font-size: 12px; margin: 5px 0; padding-left: 15px;">
            <li>WASD = posun mapy</li>
            <li>Q/E = zoom</li>
            <li>Klik = p≈ôidat marker</li>
        </ul>
        <p><strong>VR:</strong></p>
        <ul style="font-size: 12px; margin: 5px 0; padding-left: 15px;">
            <li>Trigger = plynul√Ω drag mapy</li>
            <li>Lev√Ω joystick = pohyb ve VR prostoru</li>
            <li>Prav√Ω joystick Y = zoom in/out</li>
            <li>Prav√Ω joystick X = rotace mapy</li>
        </ul>
        <div id="coords">GPS: 50.075, 14.438</div>
        <div id="zoomInfo">Zoom: 10</div>
        <div id="status">Inicializuji...</div>
    </div>
    
    <div id="controls">
        <h4>üéÆ Ovl√°d√°n√≠</h4>
        <div>
            <button onclick="jumpTo(50.075, 14.438)">üèõÔ∏è Praha</button>
            <button onclick="jumpTo(51.507, -0.128)">üá¨üáß Lond√Ωn</button>
        </div>
        <div>
            <button onclick="jumpTo(40.713, -74.006)">üóΩ NYC</button>
            <button onclick="jumpTo(35.676, 139.650)">üóæ Tokio</button>
        </div>
        <div>
            <button onclick="clearMarkers()">üóëÔ∏è Sma≈æ markery</button>
        </div>
    </div>
    
    <div class="loading" id="loading">üöÄ Naƒç√≠t√°m VR mapu...</div>
    <div id="vrButton"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script type="module">
        import { VRButton } from 'https://cdn.skypack.dev/three@0.128.0/examples/jsm/webxr/VRButton.js';
        import { XRControllerModelFactory } from 'https://cdn.skypack.dev/three@0.128.0/examples/jsm/webxr/XRControllerModelFactory.js';
        
        // === NASTAVEN√ç ===
        let scene, camera, renderer, mapGroup, userGroup;
        let controller1, controller2, controllerGrip1, controllerGrip2;
        let raycaster, mouse = new THREE.Vector2();
        let markers = [];
        
        // === MAPA STAV ===
        let mapCenter = { lat: 50.075, lng: 14.438 }; // Praha
        let mapZoom = 10;
        let tiles = [];
        let mapPlane;
        
        // === VR STAV ===
        let isVR = false;
        let controllers = [];
        let vrInputStates = new Map();
        
        // === DRAG STAV ===
        let isDragging = false;
        let dragStartPosition = null;
        let dragStartMapCenter = null;
        let dragController = null;
        let mapOffset = { x: 0, y: 0 }; // Pro plynul√Ω drag
        
        // === INICIALIZACE ===
        function init() {
            console.log('üöÄ Inicializuji jednoduchou VR mapu...');
            
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            
            // Camera - d√°l od mapy pro lep≈°√≠ pohled
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 0, 80); // D√°l dozadu
            camera.lookAt(0, 0, 0);
            
            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.xr.enabled = true;
            document.body.appendChild(renderer.domElement);
            
            // VR Button
            document.getElementById('vrButton').appendChild(VRButton.createButton(renderer));
            
            setupLighting();
            createSimpleMap();
            setupVRControllers();
            setupDesktopControls();
            
            // Animation loop
            renderer.setAnimationLoop(animate);
            
            document.getElementById('loading').style.display = 'none';
            updateStatus('‚úÖ Mapa p≈ôipravena');
        }
        
        // === OSVƒöTLEN√ç ===
        function setupLighting() {
            const ambientLight = new THREE.AmbientLight(0x404040, 0.8);
            scene.add(ambientLight);
            
            const sunLight = new THREE.DirectionalLight(0xffffff, 1.0);
            sunLight.position.set(50, 100, 50);
            scene.add(sunLight);
        }
        
        // === JEDNODUCH√Å MAPA ===
        function createSimpleMap() {
            mapGroup = new THREE.Group();
            scene.add(mapGroup);
            
            // Vytvo≈ô jednoduchou grid mapu
            createMapGrid();
            loadCenterTile();
        }
        
        function createMapGrid() {
            // Grid podklad (vertik√°ln√≠)
            const gridHelper = new THREE.GridHelper(100, 20, 0x444444, 0x444444);
            gridHelper.rotation.x = Math.PI / 2; // Otoƒçit grid vertik√°lnƒõ
            gridHelper.position.z = -1;
            mapGroup.add(gridHelper);
            
            // Hlavn√≠ mapa plane (vertik√°lnƒõ proti kame≈ôe)
            const geometry = new THREE.PlaneGeometry(50, 50);
            const material = new THREE.MeshBasicMaterial({ 
                color: 0x90EE90,
                transparent: true,
                opacity: 0.8
            });
            
            mapPlane = new THREE.Mesh(geometry, material);
            // ≈Ω√°dn√° rotace - plane je u≈æ vertik√°ln√≠ ve v√Ωchoz√≠m stavu
            mapPlane.position.z = 0; // P≈ôed kamerou
            mapPlane.name = 'mapPlane';
            mapGroup.add(mapPlane);
        }
        
        function loadCenterTile() {
            // Naƒçti jeden tile z OpenStreetMap
            const zoom = Math.floor(mapZoom);
            const tileX = Math.floor((mapCenter.lng + 180) / 360 * Math.pow(2, zoom));
            const tileY = Math.floor((1 - Math.log(Math.tan(mapCenter.lat * Math.PI / 180) + 1 / Math.cos(mapCenter.lat * Math.PI / 180)) / Math.PI) / 2 * Math.pow(2, zoom));
            
            const tileUrl = `https://tile.openstreetmap.org/${zoom}/${tileX}/${tileY}.png`;
            
            updateStatus(`üì° Naƒç√≠t√°m tile: ${zoom}/${tileX}/${tileY}`);
            
            const loader = new THREE.TextureLoader();
            loader.setCrossOrigin('anonymous');
            
            loader.load(
                tileUrl,
                (texture) => {
                    mapPlane.material.map = texture;
                    mapPlane.material.needsUpdate = true;
                    updateStatus(`‚úÖ Tile naƒçten: ${mapCenter.lat.toFixed(3)}, ${mapCenter.lng.toFixed(3)}`);
                },
                undefined,
                (error) => {
                    console.warn('Nepoda≈ôilo se naƒç√≠st tile:', error);
                    updateStatus('‚ö†Ô∏è Probl√©m s naƒç√≠t√°n√≠m tile');
                }
            );
        }
        
        // === VR OVLADAƒåE ===
        function setupVRControllers() {
            console.log('üéÆ Nastavuji VR ovladaƒçe...');
            
            const controllerModelFactory = new XRControllerModelFactory();
            raycaster = new THREE.Raycaster();
            
            // Controller 0 (prav√Ω obvykle)
            controller1 = renderer.xr.getController(0);
            controller1.addEventListener('selectstart', () => onControllerSelect(0, true));
            controller1.addEventListener('selectend', () => onControllerSelect(0, false));
            controller1.addEventListener('squeezestart', () => onControllerSqueeze(0, true));
            controller1.addEventListener('squeezeend', () => onControllerSqueeze(0, false));
            userGroup.add(controller1);
            
            controllerGrip1 = renderer.xr.getControllerGrip(0);
            controllerGrip1.add(controllerModelFactory.createControllerModel(controllerGrip1));
            userGroup.add(controllerGrip1);
            
            // Controller 1 (lev√Ω obvykle)  
            controller2 = renderer.xr.getController(1);
            controller2.addEventListener('selectstart', () => onControllerSelect(1, true));
            controller2.addEventListener('selectend', () => onControllerSelect(1, false));
            controller2.addEventListener('squeezestart', () => onControllerSqueeze(1, true));
            controller2.addEventListener('squeezeend', () => onControllerSqueeze(1, false));
            userGroup.add(controller2);
            
            controllerGrip2 = renderer.xr.getControllerGrip(1);
            controllerGrip2.add(controllerModelFactory.createControllerModel(controllerGrip2));
            userGroup.add(controllerGrip2);
            
            // P≈ôidej laser pointery
            addLaserToController(controller1);
            addLaserToController(controller2);
            
            controllers = [controller1, controller2];
        }
        
        function addLaserToController(controller) {
            const geometry = new THREE.BufferGeometry().setFromPoints([
                new THREE.Vector3(0, 0, 0),
                new THREE.Vector3(0, 0, -1)
            ]);
            
            const line = new THREE.Line(geometry, new THREE.LineBasicMaterial({ color: 0xff0000 }));
            line.name = 'laser';
            line.scale.z = 15;
            controller.add(line);
        }
        
        // === VR EVENTY ===
        function onControllerSelect(controllerIndex, pressed) {
            console.log(`Controller ${controllerIndex} trigger: ${pressed}`);
            
            const controller = controllers[controllerIndex];
            
            if (pressed) {
                // Zaƒç√°tek drag
                isDragging = true;
                dragController = controller;
                dragStartPosition = controller.position.clone();
                dragStartMapCenter = { lat: mapCenter.lat, lng: mapCenter.lng };
                mapOffset = { x: 0, y: 0 }; // Reset offset
                
                console.log('üéØ Zaƒç√°tek plynul√©ho drag');
                updateStatus('üéØ Drag mapa - plynule');
                
            } else {
                // Konec drag
                if (isDragging) {
                    // P≈ôevod vizu√°ln√≠ho offsetu na skuteƒçnou zmƒõnu mapCenter
                    const dragToGPS = 0.01; // Conversion factor
                    mapCenter.lng -= mapOffset.x * dragToGPS;
                    mapCenter.lat += mapOffset.y * dragToGPS;
                    
                    // Clamp coordinates
                    mapCenter.lat = Math.max(-85, Math.min(85, mapCenter.lat));
                    mapCenter.lng = Math.max(-180, Math.min(180, mapCenter.lng));
                    
                    // Reset vizu√°ln√≠ pozice
                    mapGroup.position.x = 0;
                    mapGroup.position.y = 0;
                    mapOffset = { x: 0, y: 0 };
                    
                    isDragging = false;
                    dragController = null;
                    dragStartPosition = null;
                    dragStartMapCenter = null;
                    
                    console.log('üéØ Konec drag - naƒç√≠t√°m nov√Ω tile');
                    updateStatus('‚úÖ Drag ukonƒçen - loading');
                    
                    // Naƒçti nov√Ω tile po drag
                    loadCenterTile();
                }
            }
        }
        
        function onControllerSqueeze(controllerIndex, pressed) {
            console.log(`Controller ${controllerIndex} squeeze: ${pressed}`);
            vrInputStates.set(`squeeze_${controllerIndex}`, pressed);
        }
        
        function getControllerIntersections(controller) {
            const tempMatrix = new THREE.Matrix4();
            tempMatrix.identity().extractRotation(controller.matrixWorld);
            
            raycaster.ray.origin.setFromMatrixPosition(controller.matrixWorld);
            raycaster.ray.direction.set(0, 0, -1).applyMatrix4(tempMatrix);
            
            return raycaster.intersectObjects([mapPlane, ...markers]);
        }
        
        // === VR INPUT HANDLING ===
        function updateVRInput() {
            if (!renderer.xr.isPresenting) return;
            
            const session = renderer.xr.getSession();
            if (!session || !session.inputSources) return;
            
            // Sleduj drag bƒõhem dr≈æen√≠ trigger - PLYNUL√ù DRAG
            if (isDragging && dragController && dragStartPosition && dragStartMapCenter) {
                const currentPosition = dragController.position.clone();
                const deltaPosition = currentPosition.sub(dragStartPosition);
                
                // P≈ôevod VR pohybu na offset mapy (OKAM≈ΩIT√ù vizu√°ln√≠ feedback)
                const dragSensitivity = 30; // Zv√Ω≈°en√° citlivost
                mapOffset.x = deltaPosition.x * dragSensitivity;
                mapOffset.y = deltaPosition.y * dragSensitivity;
                
                // Aplikuj offset na mapGroup pro okam≈æit√Ω vizu√°ln√≠ efekt
                mapGroup.position.x = mapOffset.x;
                mapGroup.position.y = mapOffset.y;
                
                console.log(`üéØ Plynul√Ω drag: ${deltaPosition.x.toFixed(3)}, ${deltaPosition.y.toFixed(3)}`);
            }
            
            // Projdi v≈°echny input sources pro joysticky
            for (let i = 0; i < session.inputSources.length; i++) {
                const inputSource = session.inputSources[i];
                if (!inputSource || !inputSource.gamepad) continue;
                
                const gamepad = inputSource.gamepad;
                
                // Joysticky
                if (gamepad.axes && gamepad.axes.length >= 4) {
                    const leftThumbstickX = gamepad.axes[0];   // Lev√Ω X
                    const leftThumbstickY = gamepad.axes[1];   // Lev√Ω Y
                    const rightThumbstickX = gamepad.axes[2];  // Prav√Ω X  
                    const rightThumbstickY = gamepad.axes[3];  // Prav√Ω Y
                    
                    // LEV√ù JOYSTICK = LOCOMOTION (pohyb ve VR prostoru)
                    if (Math.abs(leftThumbstickX) > 0.1 || Math.abs(leftThumbstickY) > 0.1) {
                        const moveSpeed = 0.5; // Rychlost pohybu
                        
                        // P≈ôevod thumbstick pohybu na world space pohyb
                        const forward = new THREE.Vector3(0, 0, -1);
                        const right = new THREE.Vector3(1, 0, 0);
                        
                        // Aplikuj rotaci headset pro spr√°vn√Ω smƒõr
                        forward.applyQuaternion(userGroup.quaternion);
                        right.applyQuaternion(userGroup.quaternion);
                        
                        // Pohyb dop≈ôedu/dozadu
                        userGroup.position.add(forward.multiplyScalar(leftThumbstickY * moveSpeed));
                        // Pohyb vlevo/vpravo  
                        userGroup.position.add(right.multiplyScalar(leftThumbstickX * moveSpeed));
                        
                        console.log(`üö∂ Locomotion: ${leftThumbstickX.toFixed(2)}, ${leftThumbstickY.toFixed(2)}`);
                    }
                    
                    // PRAV√ù JOYSTICK = ZOOM
                    if (Math.abs(rightThumbstickY) > 0.1) {
                        const zoomSpeed = 0.08;
                        mapZoom += rightThumbstickY * zoomSpeed; // Nahoru = zoom in
                        mapZoom = Math.max(1, Math.min(18, mapZoom));
                        
                        console.log(`üîç Prav√Ω joystick zoom: ${mapZoom.toFixed(1)}`);
                        
                        // Reload tile p≈ôi zoom zmƒõnƒõ
                        if (Math.random() < 0.1) {
                            loadCenterTile();
                        }
                    }
                    
                    // PRAV√ù JOYSTICK X = ROTACE MAPY (bonus)
                    if (Math.abs(rightThumbstickX) > 0.1) {
                        const rotSpeed = 0.02;
                        mapGroup.rotation.z += rightThumbstickX * rotSpeed;
                        console.log(`üîÑ Rotace mapy: ${(mapGroup.rotation.z * 180 / Math.PI).toFixed(1)}¬∞`);
                    }
                }
            }
        }
        
        // === DESKTOP OVL√ÅD√ÅN√ç ===
        function setupDesktopControls() {
            const keys = {};
            
            document.addEventListener('keydown', (e) => {
                keys[e.key.toLowerCase()] = true;
            });
            
            document.addEventListener('keyup', (e) => {
                keys[e.key.toLowerCase()] = false;
            });
            
            // Continuous movement
            function updateDesktopMovement() {
                const moveSpeed = 0.01;
                
                if (keys['w']) {
                    mapCenter.lat += moveSpeed;
                    loadCenterTile();
                }
                if (keys['s']) {
                    mapCenter.lat -= moveSpeed;
                    loadCenterTile();
                }
                if (keys['a']) {
                    mapCenter.lng -= moveSpeed;
                    loadCenterTile();
                }
                if (keys['d']) {
                    mapCenter.lng += moveSpeed;
                    loadCenterTile();
                }
                if (keys['q'] && mapZoom < 18) {
                    mapZoom += 0.1;
                    loadCenterTile();
                }
                if (keys['e'] && mapZoom > 1) {
                    mapZoom -= 0.1;
                    loadCenterTile();
                }
                
                // Clamp coordinates
                mapCenter.lat = Math.max(-85, Math.min(85, mapCenter.lat));
                mapCenter.lng = Math.max(-180, Math.min(180, mapCenter.lng));
                
                requestAnimationFrame(updateDesktopMovement);
            }
            updateDesktopMovement();
            
            // Mouse click
            renderer.domElement.addEventListener('click', onMapClick);
        }
        
        function onMapClick(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects([mapPlane]);
            
            if (intersects.length > 0) {
                const point = intersects[0].point;
                const gps = worldToGPS(point);
                addMarker(gps.lat, gps.lng, `Desktop Marker ${markers.length + 1}`);
                updateGPSDisplay(gps.lat, gps.lng);
                updateStatus(`üìç Desktop marker: ${gps.lat.toFixed(4)}, ${gps.lng.toFixed(4)}`);
            }
        }
        
        // === MARKERY ===
        function addMarker(lat, lng, label, color = 0xff0000) {
            const worldPos = gpsToWorld(lat, lng);
            
            // Marker geometrie
            const geometry = new THREE.ConeGeometry(1, 3, 8);
            const material = new THREE.MeshBasicMaterial({ color: color });
            const marker = new THREE.Mesh(geometry, material);
            
            marker.position.set(worldPos.x, 1.5, worldPos.z);
            marker.userData = { label, lat, lng };
            marker.name = 'marker';
            
            // P≈ôidej marker do mapGroup aby se pohyboval s mapou
            mapGroup.add(marker);
            markers.push(marker);
            
            console.log(`üìç Marker p≈ôid√°n: ${label} na ${lat.toFixed(4)}, ${lng.toFixed(4)}`);
        }
        
        // === KOORDIN√ÅTY (ZJEDNODU≈†EN√â) ===
        function gpsToWorld(lat, lng) {
            // Jednoduch√Ω p≈ôevod - ne Mercator, jen line√°rn√≠
            const scale = 50 / 180; // 50 units = 180 degrees
            const x = lng * scale;
            const z = -lat * scale; // Negative Z for correct orientation
            return { x, z };
        }
        
        function worldToGPS(worldPos) {
            const scale = 180 / 50;
            const lng = worldPos.x * scale;
            const lat = -worldPos.z * scale;
            return { lat, lng };
        }
        
        // === UTILITY FUNKCE ===
        function jumpTo(lat, lng) {
            mapCenter.lat = lat;
            mapCenter.lng = lng;
            loadCenterTile();
            updateStatus(`‚úàÔ∏è Skok na: ${lat.toFixed(3)}, ${lng.toFixed(3)}`);
        }
        
        function clearMarkers() {
            markers.forEach(marker => mapGroup.remove(marker));
            markers = [];
            updateStatus('üóëÔ∏è Markery smaz√°ny');
        }
        
        function updateGPSDisplay(lat = mapCenter.lat, lng = mapCenter.lng) {
            document.getElementById('coords').textContent = `GPS: ${lat.toFixed(3)}, ${lng.toFixed(3)}`;
        }
        
        function updateZoomDisplay() {
            document.getElementById('zoomInfo').textContent = `Zoom: ${mapZoom.toFixed(1)}`;
        }
        
        function updateStatus(message) {
            document.getElementById('status').textContent = message;
            console.log(message);
        }
        
        // === ANIMATION LOOP ===
        function animate() {
            // Update VR input
            updateVRInput();
            
            // Animace marker≈Ø
            markers.forEach((marker, i) => {
                marker.rotation.y += 0.02;
                marker.position.y = 1.5 + Math.sin(Date.now() * 0.003 + i) * 0.2;
            });
            
            // Update UI
            updateGPSDisplay();
            updateZoomDisplay();
            
            renderer.render(scene, camera);
        }
        
        // === RESIZE ===
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        // === GLOB√ÅLN√ç FUNKCE ===
        window.jumpTo = jumpTo;
        window.clearMarkers = clearMarkers;
        
        // === START ===
        init();
        console.log('üó∫Ô∏è Jednoduch√° VR mapa p≈ôipravena!');
        
    </script>
</body>
</html>
