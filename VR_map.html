<!doctype html>
<html>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

        <title>Babylon.js sample code</title>

        <!-- Babylon.js -->
        <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.6.2/dat.gui.min.js"></script>
        <script src="https://assets.babylonjs.com/generated/Assets.js"></script>
        <script src="https://cdn.babylonjs.com/recast.js"></script>
        <script src="https://cdn.babylonjs.com/ammo.js"></script>
        <script src="https://cdn.babylonjs.com/havok/HavokPhysics_umd.js"></script>
        <script src="https://cdn.babylonjs.com/cannon.js"></script>
        <script src="https://cdn.babylonjs.com/Oimo.js"></script>
        <script src="https://cdn.babylonjs.com/earcut.min.js"></script>
        <script src="https://cdn.babylonjs.com/babylon.js"></script>
        <script src="https://cdn.babylonjs.com/materialsLibrary/babylonjs.materials.min.js"></script>
        <script src="https://cdn.babylonjs.com/proceduralTexturesLibrary/babylonjs.proceduralTextures.min.js"></script>
        <script src="https://cdn.babylonjs.com/postProcessesLibrary/babylonjs.postProcess.min.js"></script>
        <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.js"></script>
        <script src="https://cdn.babylonjs.com/serializers/babylonjs.serializers.min.js"></script>
        <script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script>
        <script src="https://cdn.babylonjs.com/addons/babylonjs.addons.min.js"></script>
        <script src="https://cdn.babylonjs.com/inspector/babylon.inspector.bundle.js"></script>

        <style>
            html,
            body {
                overflow: hidden;
                width: 100%;
                height: 100%;
                margin: 0;
                padding: 0;
            }

            #renderCanvas {
                width: 100%;
                height: 100%;
                touch-action: none;
            }

            #canvasZone {
                width: 100%;
                height: 100%;
            }
        </style>
    </head>
    <body>
        <div id="canvasZone"><canvas id="renderCanvas"></canvas></div>
        <script>
                    var canvas = document.getElementById("renderCanvas");

                    var startRenderLoop = function (engine, canvas) {
                        engine.runRenderLoop(function () {
                            if (sceneToRender && sceneToRender.activeCamera) {
                                sceneToRender.render();
                            }
                        });
                    }

                    var engine = null;
        var scene = null;
        var sceneToRender = null;
        var createDefaultEngine = function() { return new BABYLON.Engine(canvas, true, { preserveDrawingBuffer: true, stencil: true,  disableWebGL2Support: false}); };
        var createScene = async function () {
    // load lil-gui for some sample HTML
    // https://lil-gui.georgealways.com
    await loadScript("https://cdn.jsdelivr.net/npm/lil-gui@0.19");
    const GUI = lil.GUI;

    // gui code borrowed from three.js examples
    // https://github.com/mrdoob/three.js/blob/master/examples/webxr_vr_sandbox.html
    const parameters = {
        radius: 0.6,
        tube: 0.2,
        tubularSegments: 150,
        radialSegments: 20,
        p: 2,
        q: 3,
        thickness: 0.5
    };
    function onChange() {
        console.log("GUI changed.");
    }
    const gui = new GUI({ width: 300 });
    gui.add(parameters, 'radius', 0.0, 1.0).onChange(onChange);
    gui.add(parameters, 'tube', 0.0, 1.0).onChange(onChange);
    gui.add(parameters, 'tubularSegments', 10, 150, 1).onChange(onChange);
    gui.add(parameters, 'radialSegments', 2, 20, 1).onChange(onChange);
    gui.add(parameters, 'p', 1, 10, 1).onChange(onChange);
    gui.add(parameters, 'q', 0, 10, 1).onChange(onChange);
    gui.add(parameters, 'thickness', 0, 1).onChange(onChange);
    gui.domElement.style.visibility = 'hidden';

    // This creates a basic Babylon Scene object (non-mesh)
    var scene = new BABYLON.Scene(engine);

    // This creates and positions a free camera (non-mesh)
    var camera = new BABYLON.FreeCamera("camera1", new BABYLON.Vector3(0, 5, -10), scene);

    // This targets the camera to scene origin
    camera.setTarget(BABYLON.Vector3.Zero());

    // This attaches the camera to the canvas
    camera.attachControl(canvas, true);

    // This creates a light, aiming 0,1,0 - to the sky (non-mesh)
    var light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, 1, 0), scene);

    // Default intensity is 1. Let's dim the light a small amount
    light.intensity = 0.7;

    // create a texture from our dummy GUI above
    new HtmlMesh(gui.domElement, scene);

    // XR
    const xrHelper = await scene.createDefaultXRExperienceAsync();

    return scene;
};

// HtmlTexture converts a HTML DOM element into a texture using html2canvas
class HtmlTexture extends BABYLON.DynamicTexture {
    constructor(domElement, scene) {
        super("HtmlTexture", html2canvas(domElement), scene);
        this.domElement = domElement;

        // Create an observer on the DOM, and run html2canvas update in the next loop
        const observer = new MutationObserver(() => {

            if (!this.scheduleUpdate) {
                // ideally should use xr.requestAnimationFrame, here setTimeout to avoid passing the renderer
                this.scheduleUpdate = setTimeout(() => this.update(), 16);
            }

        });

        const config = { attributes: true, childList: true, subtree: true, characterData: true };
        observer.observe(domElement, config);

        this.observer = observer;
    }

    get width() {
        return this._canvas.width;
    }

    get height() {
        return this._canvas.height;
    }

    update() {
        html2canvas(this.domElement);
        super.update()
        this.scheduleUpdate = null;
    }
}

// creates a plane mesh and material with an attached HtmlTexture
// handles events for HTML interactions
class HtmlMesh { // TODO: derive from mesh class?
    constructor(domElement, scene) {
        this.domElement = domElement;

        // create HTML texture
        this.texture = new HtmlTexture(domElement, scene);
        this.texture.hasAlpha = true;

        // create plane
        this.mesh = BABYLON.MeshBuilder.CreatePlane("plane", { height: 5, width: 5 });
        this.material = new BABYLON.StandardMaterial("Mat", scene);

        // create material
        this.material.diffuseTexture = this.texture;
        this.mesh.material = this.material;

        // remember to update or you will get NOTHING :)
        this.texture.update();

        // setup actions
        this.mesh.actionManager = new BABYLON.ActionManager(scene);

        // mousedown event on OnPickDownTrigger action
        this.mesh.actionManager.registerAction(
            new BABYLON.ExecuteCodeAction(
                {
                    trigger: BABYLON.ActionManager.OnPickDownTrigger,
                },
                (evt) => {
                    const htmlCoords = evt.additionalData.getTextureCoordinates();
                    // XXX: y coordinates are inverted between browser and 3D
                    htmlevent(this.domElement, "mousedown", htmlCoords.x, 1 - htmlCoords.y);
                },
            )
        );

        // mouseup event on OnPickUpTrigger action
        this.mesh.actionManager.registerAction(
            new BABYLON.ExecuteCodeAction(
                {
                    trigger: BABYLON.ActionManager.OnPickUpTrigger,
                },
                (evt) => {
                    const htmlCoords = evt.additionalData.getTextureCoordinates();
                    // XXX: y coordinates are inverted between browser and 3D
                    htmlevent(this.domElement, "mouseup", htmlCoords.x, 1 - htmlCoords.y);
                },
            )
        );

        // click event on OnPickTrigger action
        this.mesh.actionManager.registerAction(
            new BABYLON.ExecuteCodeAction(
                {
                    trigger: BABYLON.ActionManager.OnPickTrigger,
                },
                (evt) => {
                    const htmlCoords = evt.additionalData.getTextureCoordinates();
                    // XXX: y coordinates are inverted between browser and 3D
                    htmlevent(this.domElement, "click", htmlCoords.x, 1 - htmlCoords.y);
                },
            )
        );

        // mousemove event on OnPointerOverTrigger action
        this.mesh.actionManager.registerAction(
            new BABYLON.ExecuteCodeAction(
                {
                    trigger: BABYLON.ActionManager.OnPointerOverTrigger,
                },
                (evt) => {
                    // XXX: additionalData is structured different for mousemove
                    const htmlCoords = evt.additionalData.pickResult.getTextureCoordinates();
                    // XXX: y coordinates are inverted between browser and 3D
                    htmlevent(this.domElement, "mousemove", htmlCoords.x, 1 - htmlCoords.y);
                },
            )
        );

        // if you set AbstractMesh.pointerOverDisableMeshTesting to
        // true, this trigger will be triggered every time you move the
        // mouse and you are still over the mesh 
        this.mesh.pointerOverDisableMeshTesting = true;
    }
}

// loads a js module
// from https://www.educative.io/answers/how-to-dynamically-load-a-js-file-in-javascript
const loadScript = (FILE_URL, async = true, type = "text/javascript") => {
    return new Promise((resolve, reject) => {
        try {
            const scriptEle = document.createElement("script");
            scriptEle.type = type;
            scriptEle.async = async;
            scriptEle.src =FILE_URL;

            scriptEle.addEventListener("load", (ev) => {
                resolve({ status: true });
            });

            scriptEle.addEventListener("error", (ev) => {
                reject({
                    status: false,
                    message: `Failed to load the script ${FILE_URL}`
                });
            });

            document.body.appendChild(scriptEle);
        } catch (error) {
            reject(error);
        }
    });
};

// borrowed from three.js with very slight modifications
// https://github.com/mrdoob/three.js/blob/43fbcefc202c176b6fc221c439e8dbdf85788679/examples/jsm/interactive/HTMLMesh.js#L125
const canvases = new WeakMap();
function html2canvas(element) {

    // TODO: move to relevant code block below
    const range = document.createRange();

    function Clipper(context) {

        const clips = [];
        let isClipping = false;

        function doClip() {

            if (isClipping) {

                isClipping = false;
                context.restore();

            }

            if (clips.length === 0) return;

            let minX = - Infinity, minY = - Infinity;
            let maxX = Infinity, maxY = Infinity;

            for (let i = 0; i < clips.length; i++) {

                const clip = clips[i];

                minX = Math.max(minX, clip.x);
                minY = Math.max(minY, clip.y);
                maxX = Math.min(maxX, clip.x + clip.width);
                maxY = Math.min(maxY, clip.y + clip.height);

            }

            context.save();
            context.beginPath();
            context.rect(minX, minY, maxX - minX, maxY - minY);
            context.clip();

            isClipping = true;

        }

        return {

            add: function (clip) {

                clips.push(clip);
                doClip();

            },

            remove: function () {

                clips.pop();
                doClip();

            }

        };

    }

    function drawText(style, x, y, string) {

        if (string !== '') {

            if (style.textTransform === 'uppercase') {

                string = string.toUpperCase();

            }

            context.font = style.fontWeight + ' ' + style.fontSize + ' ' + style.fontFamily;
            context.textBaseline = 'top';
            context.fillStyle = style.color;
            context.fillText(string, x, y + parseFloat(style.fontSize) * 0.1);

        }

    }

    function buildRectPath(x, y, w, h, r) {

        if (w < 2 * r) r = w / 2;
        if (h < 2 * r) r = h / 2;

        context.beginPath();
        context.moveTo(x + r, y);
        context.arcTo(x + w, y, x + w, y + h, r);
        context.arcTo(x + w, y + h, x, y + h, r);
        context.arcTo(x, y + h, x, y, r);
        context.arcTo(x, y, x + w, y, r);
        context.closePath();

    }

    function drawBorder(style, which, x, y, width, height) {

        const borderWidth = style[which + 'Width'];
        const borderStyle = style[which + 'Style'];
        const borderColor = style[which + 'Color'];

        if (borderWidth !== '0px' && borderStyle !== 'none' && borderColor !== 'transparent' && borderColor !== 'rgba(0, 0, 0, 0)') {

            context.strokeStyle = borderColor;
            context.lineWidth = parseFloat(borderWidth);
            context.beginPath();
            context.moveTo(x, y);
            context.lineTo(x + width, y + height);
            context.stroke();

        }

    }

    function drawElement(element, style) {

        let x = 0, y = 0, width = 0, height = 0;

        if (element.nodeType === Node.TEXT_NODE) {

            // text

            range.selectNode(element);

            const rect = range.getBoundingClientRect();

            x = rect.left - offset.left - 0.5;
            y = rect.top - offset.top - 0.5;
            width = rect.width;
            height = rect.height;

            drawText(style, x, y, element.nodeValue.trim());

        } else if (element.nodeType === Node.COMMENT_NODE) {

            return;

        } else if (element instanceof HTMLCanvasElement) {

            // Canvas element
            if (element.style.display === 'none') return;

            const rect = element.getBoundingClientRect();

            x = rect.left - offset.left - 0.5;
            y = rect.top - offset.top - 0.5;

            context.save();
            const dpr = window.devicePixelRatio;
            context.scale(1 / dpr, 1 / dpr);
            context.drawImage(element, x, y);
            context.restore();

        } else if (element instanceof HTMLImageElement) {

            if (element.style.display === 'none') return;

            const rect = element.getBoundingClientRect();

            x = rect.left - offset.left - 0.5;
            y = rect.top - offset.top - 0.5;
            width = rect.width;
            height = rect.height;

            context.drawImage(element, x, y, width, height);

        } else {

            if (element.style.display === 'none') return;

            const rect = element.getBoundingClientRect();

            x = rect.left - offset.left - 0.5;
            y = rect.top - offset.top - 0.5;
            width = rect.width;
            height = rect.height;

            style = window.getComputedStyle(element);

            // Get the border of the element used for fill and border

            buildRectPath(x, y, width, height, parseFloat(style.borderRadius));

            const backgroundColor = style.backgroundColor;

            if (backgroundColor !== 'transparent' && backgroundColor !== 'rgba(0, 0, 0, 0)') {

                context.fillStyle = backgroundColor;
                context.fill();

            }

            // If all the borders match then stroke the round rectangle

            const borders = ['borderTop', 'borderLeft', 'borderBottom', 'borderRight'];

            let match = true;
            let prevBorder = null;

            for (const border of borders) {

                if (prevBorder !== null) {

                    match = (style[border + 'Width'] === style[prevBorder + 'Width']) &&
                        (style[border + 'Color'] === style[prevBorder + 'Color']) &&
                        (style[border + 'Style'] === style[prevBorder + 'Style']);

                }

                if (match === false) break;

                prevBorder = border;

            }

            if (match === true) {

                // They all match so stroke the rectangle from before allows for border-radius

                const width = parseFloat(style.borderTopWidth);

                if (style.borderTopWidth !== '0px' && style.borderTopStyle !== 'none' && style.borderTopColor !== 'transparent' && style.borderTopColor !== 'rgba(0, 0, 0, 0)') {

                    context.strokeStyle = style.borderTopColor;
                    context.lineWidth = width;
                    context.stroke();

                }

            } else {

                // Otherwise draw individual borders

                drawBorder(style, 'borderTop', x, y, width, 0);
                drawBorder(style, 'borderLeft', x, y, 0, height);
                drawBorder(style, 'borderBottom', x, y + height, width, 0);
                drawBorder(style, 'borderRight', x + width, y, 0, height);

            }

            if (element instanceof HTMLInputElement) {

                let accentColor = style.accentColor;

                if (accentColor === undefined || accentColor === 'auto') accentColor = style.color;

                // TODO
                // color.set(accentColor);

                // const luminance = Math.sqrt(0.299 * (color.r ** 2) +
                // 0.587 * (color.g ** 2) + 0.114 * (color.b ** 2));
                const luminance = 0;
                const accentTextColor = luminance < 0.5 ? 'white' : '#111111';

                if (element.type === 'radio') {

                    buildRectPath(x, y, width, height, height);

                    context.fillStyle = 'white';
                    context.strokeStyle = accentColor;
                    context.lineWidth = 1;
                    context.fill();
                    context.stroke();

                    if (element.checked) {

                        buildRectPath(x + 2, y + 2, width - 4, height - 4, height);

                        context.fillStyle = accentColor;
                        context.strokeStyle = accentTextColor;
                        context.lineWidth = 2;
                        context.fill();
                        context.stroke();

                    }

                }

                if (element.type === 'checkbox') {

                    buildRectPath(x, y, width, height, 2);

                    context.fillStyle = element.checked ? accentColor : 'white';
                    context.strokeStyle = element.checked ? accentTextColor : accentColor;
                    context.lineWidth = 1;
                    context.stroke();
                    context.fill();

                    if (element.checked) {

                        const currentTextAlign = context.textAlign;

                        context.textAlign = 'center';

                        const properties = {
                            color: accentTextColor,
                            fontFamily: style.fontFamily,
                            fontSize: height + 'px',
                            fontWeight: 'bold'
                        };

                        drawText(properties, x + (width / 2), y, '✔');

                        context.textAlign = currentTextAlign;

                    }

                }

                if (element.type === 'range') {

                    const [min, max, value] = ['min', 'max', 'value'].map(property => parseFloat(element[property]));
                    const position = ((value - min) / (max - min)) * (width - height);

                    buildRectPath(x, y + (height / 4), width, height / 2, height / 4);
                    context.fillStyle = accentTextColor;
                    context.strokeStyle = accentColor;
                    context.lineWidth = 1;
                    context.fill();
                    context.stroke();

                    buildRectPath(x, y + (height / 4), position + (height / 2), height / 2, height / 4);
                    context.fillStyle = accentColor;
                    context.fill();

                    buildRectPath(x + position, y, height, height, height / 2);
                    context.fillStyle = accentColor;
                    context.fill();

                }

                if (element.type === 'color' || element.type === 'text' || element.type === 'number') {

                    clipper.add({ x: x, y: y, width: width, height: height });

                    drawText(style, x + parseInt(style.paddingLeft), y + parseInt(style.paddingTop), element.value);

                    clipper.remove();

                }

            }

        }

        /*
        // debug
        context.strokeStyle = '#' + Math.random().toString( 16 ).slice( - 3 );
        context.strokeRect( x - 0.5, y - 0.5, width + 1, height + 1 );
        */

        const isClipping = style.overflow === 'auto' || style.overflow === 'hidden';

        if (isClipping) clipper.add({ x: x, y: y, width: width, height: height });

        for (let i = 0; i < element.childNodes.length; i++) {

            drawElement(element.childNodes[i], style);

        }

        if (isClipping) clipper.remove();

    }

    const offset = element.getBoundingClientRect();

    let canvas = canvases.get(element);

    if (canvas === undefined) {

        canvas = document.createElement('canvas');
        canvas.width = offset.width;
        canvas.height = offset.height;
        console.log(`initial size: ${canvas.width}x${canvas.height}`)
        canvases.set(element, canvas);

    }

    const context = canvas.getContext('2d'/*, { alpha: false }*/);

    const clipper = new Clipper(context);

    // console.time( 'drawElement' );

    context.clearRect(0, 0, canvas.width, canvas.height);

    drawElement(element);

    // console.timeEnd( 'drawElement' );

    return canvas;
}

function htmlevent(element, event, x, y) {
    const mouseEventInit = {
        clientX: (x * element.offsetWidth) + element.offsetLeft,
        clientY: (y * element.offsetHeight) + element.offsetTop,
        view: element.ownerDocument.defaultView
    };

    const m = new MouseEvent(event, mouseEventInit);
    window.dispatchEvent(m);

    const rect = element.getBoundingClientRect();

    x = x * rect.width + rect.left;
    y = y * rect.height + rect.top;

    function traverse(element) {

        if (element.nodeType !== Node.TEXT_NODE && element.nodeType !== Node.COMMENT_NODE) {
            const rect = element.getBoundingClientRect();

            if (x > rect.left && x < rect.right && y > rect.top && y < rect.bottom) {
                element.dispatchEvent(new MouseEvent(event, mouseEventInit));

                if (element instanceof HTMLInputElement && element.type === 'range' && (event === 'mousedown' || event === 'click')) {
                    const [min, max] = ['min', 'max'].map(property => parseFloat(element[property]));

                    const width = rect.width;
                    const offsetX = x - rect.x;
                    const proportion = offsetX / width;
                    element.value = min + (max - min) * proportion;
                    element.dispatchEvent(new InputEvent('input', { bubbles: true }));
                }
            }

            for (let i = 0; i < element.childNodes.length; i++) {
                traverse(element.childNodes[i]);
            }
        }
    }

    traverse(element);
}
                window.initFunction = async function() {
                    
                    
                    
                    var asyncEngineCreation = async function() {
                        try {
                        return createDefaultEngine();
                        } catch(e) {
                        console.log("the available createEngine function failed. Creating the default engine instead");
                        return createDefaultEngine();
                        }
                    }

                    window.engine = await asyncEngineCreation();
                    
                    const engineOptions = window.engine.getCreationOptions?.();
                    if (!engineOptions || engineOptions.audioEngine !== false) {
                        
                    }
        if (!engine) throw 'engine should not be null.';
        startRenderLoop(engine, canvas);
        window.scene = createScene();};
        initFunction().then(() => {scene.then(returnedScene => { sceneToRender = returnedScene; });
        
                    });

                    // Resize
                    window.addEventListener("resize", function () {
                        engine.resize();
                    });
        </script>
    </body>
</html>
