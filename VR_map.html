<!doctype html>
<html>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
        <title>VR World Map</title>

        <!-- Babylon.js -->
        <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.6.2/dat.gui.min.js"></script>
        <script src="https://assets.babylonjs.com/generated/Assets.js"></script>
        <script src="https://cdn.babylonjs.com/recast.js"></script>
        <script src="https://cdn.babylonjs.com/ammo.js"></script>
        <script src="https://cdn.babylonjs.com/havok/HavokPhysics_umd.js"></script>
        <script src="https://cdn.babylonjs.com/cannon.js"></script>
        <script src="https://cdn.babylonjs.com/Oimo.js"></script>
        <script src="https://cdn.babylonjs.com/earcut.min.js"></script>
        <script src="https://cdn.babylonjs.com/babylon.js"></script>
        <script src="https://cdn.babylonjs.com/materialsLibrary/babylonjs.materials.min.js"></script>
        <script src="https://cdn.babylonjs.com/proceduralTexturesLibrary/babylonjs.proceduralTextures.min.js"></script>
        <script src="https://cdn.babylonjs.com/postProcessesLibrary/babylonjs.postProcess.min.js"></script>
        <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.js"></script>
        <script src="https://cdn.babylonjs.com/serializers/babylonjs.serializers.min.js"></script>
        <script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script>
        <script src="https://cdn.babylonjs.com/addons/babylonjs.addons.min.js"></script>
        <script src="https://cdn.babylonjs.com/inspector/babylon.inspector.bundle.js"></script>
        
        <!-- Leaflet -->
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.css" />
        <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.min.js"></script>

        <style>
            html, body {
                overflow: hidden;
                width: 100%;
                height: 100%;
                margin: 0;
                padding: 0;
            }

            #renderCanvas {
                width: 100%;
                height: 100%;
                touch-action: none;
            }

            #canvasZone {
                width: 100%;
                height: 100%;
            }

            #mapContainer {
                width: 800px;
                height: 600px;
                background: #000;
                border-radius: 10px;
                overflow: hidden;
                visibility: hidden;
                position: absolute;
                top: -9999px;
            }

            #map {
                width: 100%;
                height: 100%;
            }
        </style>
    </head>
    <body>
        <div id="canvasZone"><canvas id="renderCanvas"></canvas></div>
        
        <!-- Hidden map container for VR -->
        <div id="mapContainer">
            <div id="map"></div>
        </div>

        <script>
            var canvas = document.getElementById("renderCanvas");

            var startRenderLoop = function (engine, canvas) {
                engine.runRenderLoop(function () {
                    if (sceneToRender && sceneToRender.activeCamera) {
                        sceneToRender.render();
                    }
                });
            }

            var engine = null;
            var scene = null;
            var sceneToRender = null;
            var createDefaultEngine = function() { 
                return new BABYLON.Engine(canvas, true, { 
                    preserveDrawingBuffer: true, 
                    stencil: true,  
                    disableWebGL2Support: false
                }); 
            };

            var createScene = async function () {
                // Create basic Babylon Scene
                var scene = new BABYLON.Scene(engine);

                // Camera
                var camera = new BABYLON.FreeCamera("camera1", new BABYLON.Vector3(0, 5, -10), scene);
                camera.setTarget(BABYLON.Vector3.Zero());
                camera.attachControl(canvas, true);

                // Light
                var light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, 1, 0), scene);
                light.intensity = 0.7;

                // Initialize map first
                console.log('ðŸ—ºï¸ Starting map initialization...');
                initializeMap();

                // XR first, then create map display
                console.log('ðŸ¥½ Creating XR experience...');
                const xrHelper = await scene.createDefaultXRExperienceAsync({
                    floorMeshes: []
                });

                // Wait for XR and map to be ready
                setTimeout(() => {
                    console.log('ðŸŽ® Creating VR map display...');
                    const mapContainer = document.getElementById('mapContainer');
                    const htmlMesh = new HtmlMesh(mapContainer, scene, xrHelper);
                }, 2000);

                return scene;
            };

            // Initialize Leaflet map
            let map;
            function initializeMap() {
                console.log('ðŸ—ºï¸ Initializing offline topographic map...');
                
                map = L.map('map', {
                    center: [49.75, 15.5], // Czech Republic center
                    zoom: 2,
                    minZoom: 0,
                    maxZoom: 3,
                    zoomControl: true,
                    attributionControl: false,
                    worldCopyJump: true,
                    maxBounds: [[-85, -Infinity], [85, Infinity]],
                    maxBoundsViscosity: 1.0
                });

                console.log('ðŸ“ Map object created, adding topographic layer...');

                // Only topographic layer (GitHub available levels 0-3)
                const topoLayer = L.tileLayer('tiles_topo_labeled/{z}/{x}/{y}.png', {
                    attribution: 'ESRI Topographic (Offline)',
                    minZoom: 0,
                    maxZoom: 3,
                    maxNativeZoom: 3
                });
                
                topoLayer.on('loading', () => console.log('ðŸ”„ Topo layer loading...'));
                topoLayer.on('load', () => console.log('âœ… Topo layer loaded'));
                topoLayer.on('tileerror', (e) => console.log('âŒ Topo tile error:', e.tile.src));
                topoLayer.on('tileload', (e) => console.log('âœ… Tile loaded:', e.tile.src));
                
                topoLayer.addTo(map);

                // Map events
                map.on('moveend', () => {
                    const center = map.getCenter();
                    const zoom = map.getZoom();
                    console.log(`ðŸ—ºï¸ Map moved to: ${center.lat.toFixed(3)}, ${center.lng.toFixed(3)}, zoom: ${zoom}`);
                });

                console.log('âœ… Offline topographic map initialized (levels 0-3)');
            }

            // HtmlTexture - converts HTML DOM to texture
            class HtmlTexture extends BABYLON.DynamicTexture {
                constructor(domElement, scene) {
                    super("HtmlTexture", html2canvas(domElement), scene);
                    this.domElement = domElement;

                    const observer = new MutationObserver(() => {
                        if (!this.scheduleUpdate) {
                            this.scheduleUpdate = setTimeout(() => this.update(), 16);
                        }
                    });

                    const config = { attributes: true, childList: true, subtree: true, characterData: true };
                    observer.observe(domElement, config);
                    this.observer = observer;
                }

                get width() {
                    return this._canvas.width;
                }

                get height() {
                    return this._canvas.height;
                }

                update() {
                    html2canvas(this.domElement);
                    super.update()
                    this.scheduleUpdate = null;
                }
            }

            // HtmlMesh - creates interactive mesh with HTML content + VR support
            class HtmlMesh {
                constructor(domElement, scene, xrHelper = null) {
                    this.domElement = domElement;
                    this.scene = scene;
                    this.xrHelper = xrHelper;

                    // Create texture and mesh
                    this.texture = new HtmlTexture(domElement, scene);
                    this.texture.hasAlpha = true;

                    this.mesh = BABYLON.MeshBuilder.CreatePlane("mapPlane", { height: 6, width: 8 });
                    this.material = new BABYLON.StandardMaterial("mapMaterial", scene);
                    this.material.diffuseTexture = this.texture;
                    this.mesh.material = this.material;

                    this.texture.update();

                    // Setup desktop interaction
                    this.setupDesktopInteraction();
                    
                    // Setup VR interaction if available
                    if (xrHelper) {
                        this.setupVRInteraction();
                    }
                }

                setupDesktopInteraction() {
                    this.mesh.actionManager = new BABYLON.ActionManager(this.scene);

                    // Mouse events for desktop
                    this.mesh.actionManager.registerAction(
                        new BABYLON.ExecuteCodeAction(
                            { trigger: BABYLON.ActionManager.OnPickDownTrigger },
                            (evt) => {
                                const coords = evt.additionalData.getTextureCoordinates();
                                this.htmlevent("mousedown", coords.x, 1 - coords.y);
                            }
                        )
                    );

                    this.mesh.actionManager.registerAction(
                        new BABYLON.ExecuteCodeAction(
                            { trigger: BABYLON.ActionManager.OnPickUpTrigger },
                            (evt) => {
                                const coords = evt.additionalData.getTextureCoordinates();
                                this.htmlevent("mouseup", coords.x, 1 - coords.y);
                            }
                        )
                    );

                    this.mesh.actionManager.registerAction(
                        new BABYLON.ExecuteCodeAction(
                            { trigger: BABYLON.ActionManager.OnPickTrigger },
                            (evt) => {
                                const coords = evt.additionalData.getTextureCoordinates();
                                this.htmlevent("click", coords.x, 1 - coords.y);
                            }
                        )
                    );
                }

                setupVRInteraction() {
                    console.log('ðŸ¥½ Setting up VR interaction...');
                    
                    // Enable pointer selection for this mesh
                    this.mesh.isPickable = true;
                    
                    // Add to XR pointer selection
                    if (this.xrHelper.pointerSelection) {
                        this.xrHelper.pointerSelection.attach();
                        console.log('âœ… VR pointer selection attached');
                    }

                    // Listen for XR controller events
                    this.scene.actionManager = this.scene.actionManager || new BABYLON.ActionManager(this.scene);
                    
                    // VR controller pick events
                    this.scene.actionManager.registerAction(
                        new BABYLON.ExecuteCodeAction(
                            { trigger: BABYLON.ActionManager.OnPickTrigger },
                            (evt) => {
                                if (evt.meshUnderPointer === this.mesh) {
                                    console.log('ðŸŽ® VR trigger pressed on map');
                                    const coords = evt.additionalData.getTextureCoordinates();
                                    if (coords) {
                                        this.htmlevent("click", coords.x, 1 - coords.y);
                                    }
                                }
                            }
                        )
                    );

                    // XR input source events
                    if (this.xrHelper.input) {
                        this.xrHelper.input.onControllerAddedObservable.add((controller) => {
                            console.log('ðŸŽ® VR Controller added:', controller.inputSource.handedness);
                            
                            controller.onMotionControllerInitObservable.add((motionController) => {
                                console.log('ðŸŽ® Motion controller initialized');
                                
                                // Get main component (trigger)
                                const mainComponent = motionController.getMainComponent();
                                if (mainComponent) {
                                    // Trigger press
                                    mainComponent.onButtonStateChangedObservable.add((component) => {
                                        if (component.pressed) {
                                            console.log('ðŸŽ® VR Trigger pressed');
                                            this.handleVRPointerEvent();
                                        }
                                    });
                                }

                                // Get squeeze component if available
                                const squeezeComponent = motionController.getComponent("squeeze");
                                if (squeezeComponent) {
                                    squeezeComponent.onButtonStateChangedObservable.add((component) => {
                                        if (component.pressed) {
                                            console.log('ðŸŽ® VR Squeeze pressed');
                                            this.handleVRPointerEvent();
                                        }
                                    });
                                }
                            });
                        });
                    }
                }

                handleVRPointerEvent() {
                    // Cast ray from pointer to mesh
                    const scene = this.scene;
                    const ray = scene.createPickingRay(scene.pointerX, scene.pointerY, BABYLON.Matrix.Identity(), scene.activeCamera);
                    const hit = scene.pickWithRay(ray);
                    
                    if (hit.hit && hit.pickedMesh === this.mesh) {
                        const coords = hit.getTextureCoordinates();
                        if (coords) {
                            console.log('ðŸŽ¯ VR hit at:', coords.x, 1 - coords.y);
                            this.htmlevent("click", coords.x, 1 - coords.y);
                        }
                    }
                }

                htmlevent(event, x, y) {
                    console.log(`ðŸ–±ï¸ HTML event: ${event} at ${x.toFixed(3)}, ${y.toFixed(3)}`);
                    
                    const element = this.domElement;
                    const clientX = (x * element.offsetWidth) + element.offsetLeft;
                    const clientY = (y * element.offsetHeight) + element.offsetTop;
                    
                    const mouseEventInit = {
                        clientX: clientX,
                        clientY: clientY,
                        view: element.ownerDocument.defaultView
                    };

                    const mouseEvent = new MouseEvent(event, mouseEventInit);
                    
                    // Find target element
                    const rect = element.getBoundingClientRect();
                    const realX = x * rect.width + rect.left;
                    const realY = y * rect.height + rect.top;
                    
                    this.traverse(element, realX, realY, mouseEvent);
                }

                traverse(element, x, y, mouseEvent) {
                    if (element.nodeType !== Node.TEXT_NODE && element.nodeType !== Node.COMMENT_NODE) {
                        const rect = element.getBoundingClientRect();
                        
                        if (x >= rect.left && x <= rect.right && y >= rect.top && y <= rect.bottom) {
                            element.dispatchEvent(mouseEvent);
                        }

                        for (let i = 0; i < element.childNodes.length; i++) {
                            this.traverse(element.childNodes[i], x, y, mouseEvent);
                        }
                    }
                }
            }

            // Enhanced html2canvas for Leaflet maps
            const canvases = new WeakMap();
            function html2canvas(element) {
                const offset = element.getBoundingClientRect();
                let canvas = canvases.get(element);

                if (canvas === undefined) {
                    canvas = document.createElement('canvas');
                    canvas.width = offset.width;
                    canvas.height = offset.height;
                    canvases.set(element, canvas);
                }

                const context = canvas.getContext('2d');
                context.clearRect(0, 0, canvas.width, canvas.height);

                // Draw Leaflet map tiles
                if (map && map.getContainer()) {
                    try {
                        // Get all tile images from Leaflet
                        const mapContainer = map.getContainer();
                        const tileImages = mapContainer.querySelectorAll('.leaflet-tile');
                        
                        console.log(`Found ${tileImages.length} tiles to render`);
                        
                        // Draw background
                        context.fillStyle = '#1a1a1a';
                        context.fillRect(0, 0, canvas.width, canvas.height);
                        
                        // Draw each tile
                        tileImages.forEach(img => {
                            if (img.complete && img.naturalHeight !== 0) {
                                const rect = img.getBoundingClientRect();
                                const containerRect = mapContainer.getBoundingClientRect();
                                
                                const x = rect.left - containerRect.left;
                                const y = rect.top - containerRect.top;
                                
                                try {
                                    context.drawImage(img, x, y, rect.width, rect.height);
                                } catch (e) {
                                    console.log('Error drawing tile:', e);
                                }
                            }
                        });

                        // Draw zoom controls and other overlays
                        const overlays = mapContainer.querySelectorAll('.leaflet-control');
                        overlays.forEach(overlay => {
                            if (overlay.style.display !== 'none') {
                                const rect = overlay.getBoundingClientRect();
                                const containerRect = mapContainer.getBoundingClientRect();
                                
                                context.fillStyle = 'rgba(255, 255, 255, 0.8)';
                                context.fillRect(
                                    rect.left - containerRect.left,
                                    rect.top - containerRect.top,
                                    rect.width,
                                    rect.height
                                );
                            }
                        });
                        
                    } catch (e) {
                        console.log('Error rendering map:', e);
                        // Fallback
                        context.fillStyle = '#4a90e2';
                        context.fillRect(0, 0, canvas.width, canvas.height);
                        context.fillStyle = '#ffffff';
                        context.font = '24px Arial';
                        context.textAlign = 'center';
                        context.fillText('Loading Map...', canvas.width / 2, canvas.height / 2);
                    }
                } else {
                    // Map not ready yet
                    context.fillStyle = '#333';
                    context.fillRect(0, 0, canvas.width, canvas.height);
                    context.fillStyle = '#fff';
                    context.font = '20px Arial';
                    context.textAlign = 'center';
                    context.fillText('Initializing Map...', canvas.width / 2, canvas.height / 2);
                }

                return canvas;
            }

            // Initialize everything
            window.initFunction = async function() {
                var asyncEngineCreation = async function() {
                    try {
                        return createDefaultEngine();
                    } catch(e) {
                        console.log("Engine creation failed. Using default engine.");
                        return createDefaultEngine();
                    }
                }

                window.engine = await asyncEngineCreation();
                if (!engine) throw 'Engine should not be null.';
                
                startRenderLoop(engine, canvas);
                window.scene = createScene();
            };

            initFunction().then(() => {
                scene.then(returnedScene => { 
                    sceneToRender = returnedScene; 
                });
            });

            // Resize handler
            window.addEventListener("resize", function () {
                engine.resize();
            });
        </script>
    </body>
</html>
