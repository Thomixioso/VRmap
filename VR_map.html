<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>VR Map with Leaflet & WebXR</title>
<!-- Include Leaflet CSS -->
<link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
<!-- Include Three.js -->
<script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>
<!-- Include WebXR Polyfill if needed -->
<script src="https://cdn.jsdelivr.net/npm/webxr-polyfill@latest/dist/webxr-polyfill.min.js"></script>
<!-- Include Leaflet JS -->
<script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
</head>
<body style="margin:0; overflow:hidden;">

<!-- Container for the map (hidden, we'll render to texture) -->
<div id="mapContainer" style="display:none;">
  <div id="map" style="width: 1024px; height: 1024px;"></div>
</div>

<script>
// Initialize Leaflet map
const mapDiv = document.getElementById('map');
const map = L.map(mapDiv).setView([0, 0], 2); // Centered at equator, zoom 2

L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
  attribution: 'Â© OpenStreetMap contributors'
}).addTo(map);

// Wait until the map is ready
map.whenReady(() => {
  // Render the map to a canvas texture
  const mapCanvas = document.createElement('canvas');
  mapCanvas.width = 1024;
  mapCanvas.height = 1024;
  const ctx = mapCanvas.getContext('2d');

  // Function to update the canvas with the map
  function updateMapTexture() {
    ctx.clearRect(0, 0, mapCanvas.width, mapCanvas.height);
    // Use Leaflet's built-in method to render the map to a canvas
    // (Note: Leaflet doesn't directly support rendering to canvas, so we can use a workaround)
    // But for simplicity, we can just clone the map container into an off-screen element and draw it
    // Alternatively, you can use leaflet-image plugin or similar
    // For now, let's assume the map is static or you can update the canvas periodically
  }

  // For simplicity, let's just use the map container as an image
  // Create a texture from the map container
  const mapTexture = new THREE.TextureLoader().load('https://leafletjs.com/examples/custom-icons/leaf-green.png');

  // Since rendering Leaflet directly to texture is complex, let's use the map container as an image
  // and update the texture periodically
  const mapRendererCanvas = document.createElement('canvas');
  mapRendererCanvas.width = 1024;
  mapRendererCanvas.height = 1024;
  const mapRendererCtx = mapRendererCanvas.getContext('2d');

  function updateTexture() {
    // Draw the map container into the off-screen canvas
    html2canvas(mapDiv).then(canvas => {
      mapRendererCtx.clearRect(0, 0, 1024, 1024);
      mapRendererCtx.drawImage(canvas, 0, 0, 1024, 1024);
      mapTexture.image = mapRendererCanvas;
      mapTexture.needsUpdate = true;
    });
  }

  // Use html2canvas library to capture map container
  // Load html2canvas
  const script = document.createElement('script');
  script.src = 'https://html2canvas.hertzen.com/dist/html2canvas.min.js';
  document.head.appendChild(script);

  script.onload = () => {
    updateTexture(); // initial capture
  };

  // WebXR/Three.js Setup
  let camera, scene, renderer;
  let mapMesh;

  init();
  animate();

  function init() {
    // Renderer with WebXR enabled
    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.xr.enabled = true;
    document.body.appendChild(renderer.domElement);

    // Create scene and camera
    scene = new THREE.Scene();
    camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 1.6, 3); // initial position

    // Create a plane geometry for the map
    const geometry = new THREE.PlaneGeometry(2, 2); // size of the map plane
    const material = new THREE.MeshBasicMaterial({ map: mapTexture });
    mapMesh = new THREE.Mesh(geometry, material);
    scene.add(mapMesh);

    // Set up VR button
    document.body.appendChild(THREE.XRButton.createButton(renderer));

    // Handle window resize
    window.addEventListener('resize', onWindowResize, false);
  }

  function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  }

  // Animation loop
  function animate() {
    renderer.setAnimationLoop(render);
  }

  // Controller handling
  let controller1, controller2;
  let controllerGrip1, controllerGrip2;

  function setupControllers() {
    controller1 = renderer.xr.getController(0);
    controller2 = renderer.xr.getController(1);
    scene.add(controller1);
    scene.add(controller2);

    controllerGrip1 = renderer.xr.getControllerGrip(0);
    controllerGrip2 = renderer.xr.getControllerGrip(1);
    scene.add(controllerGrip1);
    scene.add(controllerGrip2);
  }

  // Initialize controllers once XR session starts
  renderer.xr.addEventListener('sessionstart', () => {
    setupControllers();
  });

  function render() {
    // Update map texture periodically or based on input
    // For simplicity, update on every frame
    if (typeof html2canvas !== 'undefined') {
      updateTexture();
    }

    // Handle controller input for navigation
    handleControllerInput();

    renderer.render(scene, camera);
  }

  // Navigation parameters
  const panSpeed = 0.002; // adjust as needed
  const zoomSpeed = 0.05;

  function handleControllerInput() {
    // For each controller, check axes
    [controller1, controller2].forEach(controller => {
      if (controller && controller.gamepad) {
        const axes = controller.gamepad.axes;
        // axes[0]: thumbstick X (left/right)
        // axes[1]: thumbstick Y (up/down)

        if (Math.abs(axes[0]) > 0.2 || Math.abs(axes[1]) > 0.2) {
          // Pan the map
          const deltaX = -axes[0] * panSpeed;
          const deltaY = axes[1] * panSpeed;

          // Convert pan to map movement
          // Since the map is on a plane, move it accordingly
          mapMesh.position.x += deltaX;
          mapMesh.position.y += deltaY;
        }

        // Optional: handle zoom with other axes/buttons
        // For simplicity, no zoom here
      }
    });
  }
</script>
</body>
</html>
