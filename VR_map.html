<!doctype html>
<html>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

        <title>Babylon.js VR Enhanced</title>

        <!-- Babylon.js -->
        <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.6.2/dat.gui.min.js"></script>
        <!-- Leaflet CSS and JS -->
        <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
        <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
        <script src="https://assets.babylonjs.com/generated/Assets.js"></script>
        <script src="https://cdn.babylonjs.com/recast.js"></script>
        <script src="https://cdn.babylonjs.com/ammo.js"></script>
        <script src="https://cdn.babylonjs.com/havok/HavokPhysics_umd.js"></script>
        <script src="https://cdn.babylonjs.com/cannon.js"></script>
        <script src="https://cdn.babylonjs.com/Oimo.js"></script>
        <script src="https://cdn.babylonjs.com/earcut.min.js"></script>
        <script src="https://cdn.babylonjs.com/babylon.js"></script>
        <script src="https://cdn.babylonjs.com/materialsLibrary/babylonjs.materials.min.js"></script>
        <script src="https://cdn.babylonjs.com/proceduralTexturesLibrary/babylonjs.proceduralTextures.min.js"></script>
        <script src="https://cdn.babylonjs.com/postProcessesLibrary/babylonjs.postProcess.min.js"></script>
        <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.js"></script>
        <script src="https://cdn.babylonjs.com/serializers/babylonjs.serializers.min.js"></script>
        <script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script>
        <script src="https://cdn.babylonjs.com/addons/babylonjs.addons.min.js"></script>
        <script src="https://cdn.babylonjs.com/inspector/babylon.inspector.bundle.js"></script>

        <style>
            html,
            body {
                overflow: hidden;
                width: 100%;
                height: 100%;
                margin: 0;
                padding: 0;
            }

            #renderCanvas {
                width: 100%;
                height: 100%;
                touch-action: none;
            }

            #canvasZone {
                width: 100%;
                height: 100%;
            }
        </style>
    </head>
    <body>
        <div id="canvasZone"><canvas id="renderCanvas"></canvas></div>
        <script>
                    var canvas = document.getElementById("renderCanvas");

                    var startRenderLoop = function (engine, canvas) {
                        engine.runRenderLoop(function () {
                            if (sceneToRender && sceneToRender.activeCamera) {
                                sceneToRender.render();
                            }
                        });
                    }

                    var engine = null;
        var scene = null;
        var sceneToRender = null;
        var createDefaultEngine = function() { return new BABYLON.Engine(canvas, true, { preserveDrawingBuffer: true, stencil: true,  disableWebGL2Support: false}); };
        
        var createScene = async function () {
    // load lil-gui for some sample HTML
    await loadScript("https://cdn.jsdelivr.net/npm/lil-gui@0.19");
    const GUI = lil.GUI;

    // gui code borrowed from three.js examples
    const parameters = {
        radius: 0.6,
        tube: 0.2,
        tubularSegments: 150,
        radialSegments: 20,
        p: 2,
        q: 3,
        thickness: 0.5,
        textureOffsetX: 0,
        textureOffsetY: 0,
        textureScale: 1.0,
        // Map parameters
        mapLat: 50.0755, // Prague coordinates
        mapLng: 14.4378,
        mapZoom: 10
    };
    
    function onChange() {
        console.log("GUI changed.");
        // Update texture transformation when GUI changes
        if (window.htmlMeshInstance && window.htmlMeshInstance.material) {
            updateTextureTransform();
        }
        // Update map if map parameters changed
        if (window.leafletMap) {
            updateMap();
        }
    }
    
    function updateMap() {
        if (window.leafletMap) {
            window.leafletMap.setView([parameters.mapLat, parameters.mapLng], parameters.mapZoom);
        }
    }
    
    function updateTextureTransform() {
        if (window.htmlMeshInstance && window.htmlMeshInstance.material && window.htmlMeshInstance.material.diffuseTexture) {
            const texture = window.htmlMeshInstance.material.diffuseTexture;
            texture.uOffset = parameters.textureOffsetX;
            texture.vOffset = parameters.textureOffsetY;
            texture.uScale = parameters.textureScale;
            texture.vScale = parameters.textureScale;
        }
    }
    
    const gui = new GUI({ width: 300 });
    gui.add(parameters, 'radius', 0.0, 1.0).onChange(onChange);
    gui.add(parameters, 'tube', 0.0, 1.0).onChange(onChange);
    gui.add(parameters, 'tubularSegments', 10, 150, 1).onChange(onChange);
    gui.add(parameters, 'radialSegments', 2, 20, 1).onChange(onChange);
    gui.add(parameters, 'p', 1, 10, 1).onChange(onChange);
    gui.add(parameters, 'q', 0, 10, 1).onChange(onChange);
    gui.add(parameters, 'thickness', 0, 1).onChange(onChange);
    
    // Texture control parameters
    const textureFolder = gui.addFolder('Texture Controls');
    textureFolder.add(parameters, 'textureOffsetX', -2, 2, 0.01).onChange(onChange);
    textureFolder.add(parameters, 'textureOffsetY', -2, 2, 0.01).onChange(onChange);
    textureFolder.add(parameters, 'textureScale', 0.1, 3, 0.01).onChange(onChange);
    
    // Map control parameters
    const mapFolder = gui.addFolder('World Map');
    mapFolder.add(parameters, 'mapLat', -90, 90, 0.001).onChange(onChange).name('Latitude');
    mapFolder.add(parameters, 'mapLng', -180, 180, 0.001).onChange(onChange).name('Longitude');
    mapFolder.add(parameters, 'mapZoom', 1, 18, 1).onChange(onChange).name('Zoom Level');
    
    // Create map container
    const mapContainer = document.createElement('div');
    mapContainer.id = 'mapContainer';
    mapContainer.style.width = '280px';
    mapContainer.style.height = '200px';
    mapContainer.style.margin = '10px';
    mapContainer.style.border = '1px solid #ccc';
    mapContainer.style.borderRadius = '4px';
    
    // Add map container to GUI
    const mapElement = mapFolder.add({ map: 'Interactive Map' }, 'map');
    mapElement.domElement.appendChild(mapContainer);
    
    // Initialize Leaflet map
    setTimeout(() => {
        window.leafletMap = L.map('mapContainer', {
            zoomControl: true,
            attributionControl: false
        }).setView([parameters.mapLat, parameters.mapLng], parameters.mapZoom);
        
        // Add OpenStreetMap tiles
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            maxZoom: 18,
        }).addTo(window.leafletMap);
        
        // Add a marker for current position
        window.mapMarker = L.marker([parameters.mapLat, parameters.mapLng])
            .addTo(window.leafletMap)
            .bindPopup('Current Location');
        
        // Handle map events to update parameters
        window.leafletMap.on('moveend', function() {
            const center = window.leafletMap.getCenter();
            parameters.mapLat = center.lat;
            parameters.mapLng = center.lng;
            if (window.mapMarker) {
                window.mapMarker.setLatLng([center.lat, center.lng]);
            }
            // Update GUI display (this will trigger the texture update)
            gui.updateDisplay();
        });
        
        window.leafletMap.on('zoomend', function() {
            parameters.mapZoom = window.leafletMap.getZoom();
            gui.updateDisplay();
        });
        
        // Make map container draggable for VR interaction
        mapContainer.style.cursor = 'grab';
        
        console.log("Leaflet map initialized");
    }, 100);
    
    // GUI is now visible both on screen and as texture in VR
    // gui.domElement.style.visibility = 'hidden';

    // This creates a basic Babylon Scene object (non-mesh)
    var scene = new BABYLON.Scene(engine);

    // This creates and positions a free camera (non-mesh)
    var camera = new BABYLON.FreeCamera("camera1", new BABYLON.Vector3(0, 5, -10), scene);

    // This targets the camera to scene origin
    camera.setTarget(BABYLON.Vector3.Zero());

    // This attaches the camera to the canvas
    camera.attachControl(canvas, true);

    // This creates a light, aiming 0,1,0 - to the sky (non-mesh)
    var light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, 1, 0), scene);

    // Default intensity is 1. Let's dim the light a small amount
    light.intensity = 0.7;

    // create a texture from our dummy GUI above with background texture
    const htmlMesh = new HtmlMesh(gui.domElement, scene);
    window.htmlMeshInstance = htmlMesh; // Store reference for VR controls
    
    // Add background texture to the plane
    addBackgroundTexture(htmlMesh, scene);

    // XR
    const xrHelper = await scene.createDefaultXRExperienceAsync();
    
    // Setup VR controller interactions
    if (xrHelper) {
        setupVRControls(xrHelper, parameters, updateTextureTransform);
    }

    return scene;
};

// Function to add background texture
function addBackgroundTexture(htmlMesh, scene) {
    // Create a procedural texture for background
    const backgroundTexture = new BABYLON.DynamicTexture("backgroundTexture", {width: 512, height: 512}, scene);
    
    // Draw a simple grid pattern
    const context = backgroundTexture.getContext();
    context.fillStyle = "#2c3e50";
    context.fillRect(0, 0, 512, 512);
    
    // Draw grid lines
    context.strokeStyle = "#34495e";
    context.lineWidth = 2;
    for (let i = 0; i < 512; i += 32) {
        context.beginPath();
        context.moveTo(i, 0);
        context.lineTo(i, 512);
        context.stroke();
        
        context.beginPath();
        context.moveTo(0, i);
        context.lineTo(512, i);
        context.stroke();
    }
    
    // Add some decorative elements
    context.fillStyle = "#3498db";
    for (let i = 0; i < 10; i++) {
        const x = Math.random() * 512;
        const y = Math.random() * 512;
        const radius = Math.random() * 20 + 5;
        context.beginPath();
        context.arc(x, y, radius, 0, Math.PI * 2);
        context.fill();
    }
    
    backgroundTexture.update();
    
    // Create a background plane behind the HTML mesh
    const backgroundPlane = BABYLON.MeshBuilder.CreatePlane("backgroundPlane", { height: 5.2, width: 5.2 }, scene);
    const backgroundMaterial = new BABYLON.StandardMaterial("backgroundMat", scene);
    backgroundMaterial.diffuseTexture = backgroundTexture;
    backgroundMaterial.emissiveTexture = backgroundTexture;
    backgroundMaterial.emissiveColor = new BABYLON.Color3(0.3, 0.3, 0.3);
    backgroundPlane.material = backgroundMaterial;
    backgroundPlane.position.z = 0.01; // Slightly behind the HTML mesh
    
    // Make HTML texture semi-transparent
    if (htmlMesh.material) {
        htmlMesh.material.diffuseTexture.hasAlpha = true;
        htmlMesh.material.useAlphaFromDiffuseTexture = true;
    }
}

// Setup VR controller interactions for pan and zoom
function setupVRControls(xrHelper, parameters, updateTextureTransform) {
    let isDragging = false;
    let lastControllerPosition = null;
    let dragStartPosition = { offsetX: parameters.textureOffsetX, offsetY: parameters.textureOffsetY };
    let isMapDragging = false;
    let mapDragStart = { lat: parameters.mapLat, lng: parameters.mapLng };
    
    xrHelper.input.onControllerAddedObservable.add((controller) => {
        controller.onMotionControllerInitObservable.add((motionController) => {
            console.log("VR Controller connected:", motionController.handedness);
            
            // Handle trigger press for dragging
            const triggerComponent = motionController.getComponent("xr-standard-trigger");
            if (triggerComponent) {
                triggerComponent.onButtonStateChangedObservable.add((component) => {
                    if (component.pressed) {
                        // Start dragging
                        isDragging = true;
                        lastControllerPosition = controller.pointer.position.clone();
                        dragStartPosition = { 
                            offsetX: parameters.textureOffsetX, 
                            offsetY: parameters.textureOffsetY 
                        };
                        mapDragStart = { 
                            lat: parameters.mapLat, 
                            lng: parameters.mapLng 
                        };
                        console.log("Started dragging");
                    } else {
                        // Stop dragging
                        isDragging = false;
                        isMapDragging = false;
                        lastControllerPosition = null;
                        console.log("Stopped dragging");
                    }
                });
            }
            
            // Handle squeeze for zoom
            const squeezeComponent = motionController.getComponent("xr-standard-squeeze");
            if (squeezeComponent) {
                squeezeComponent.onButtonStateChangedObservable.add((component) => {
                    if (component.pressed) {
                        // Zoom texture out
                        parameters.textureScale = Math.max(0.1, parameters.textureScale - 0.1);
                        updateTextureTransform();
                        console.log("Texture zoom out, scale:", parameters.textureScale);
                    }
                });
            }
            
            // Handle thumbstick for zoom control
            const thumbstickComponent = motionController.getComponent("xr-standard-thumbstick");
            if (thumbstickComponent) {
                thumbstickComponent.onAxisValueChangedObservable.add((axes) => {
                    if (Math.abs(axes.y) > 0.5) {
                        // Use thumbstick Y axis for texture zoom
                        const zoomSpeed = 0.02;
                        if (axes.y > 0.5) {
                            parameters.textureScale = Math.min(3.0, parameters.textureScale + zoomSpeed);
                        } else if (axes.y < -0.5) {
                            parameters.textureScale = Math.max(0.1, parameters.textureScale - zoomSpeed);
                        }
                        updateTextureTransform();
                    }
                    
                    // Use thumbstick X axis for map zoom
                    if (Math.abs(axes.x) > 0.5 && window.leafletMap) {
                        if (axes.x > 0.5) {
                            parameters.mapZoom = Math.min(18, parameters.mapZoom + 0.1);
                        } else if (axes.x < -0.5) {
                            parameters.mapZoom = Math.max(1, parameters.mapZoom - 0.1);
                        }
                        window.leafletMap.setZoom(Math.round(parameters.mapZoom));
                    }
                });
            }
            
            // Handle A/X button for reset
            const aButtonComponent = motionController.getComponent("a-button") || motionController.getComponent("x-button");
            if (aButtonComponent) {
                aButtonComponent.onButtonStateChangedObservable.add((component) => {
                    if (component.pressed) {
                        // Reset texture transform
                        parameters.textureOffsetX = 0;
                        parameters.textureOffsetY = 0;
                        parameters.textureScale = 1.0;
                        updateTextureTransform();
                        
                        // Reset map to Prague
                        parameters.mapLat = 50.0755;
                        parameters.mapLng = 14.4378;
                        parameters.mapZoom = 10;
                        if (window.leafletMap) {
                            window.leafletMap.setView([parameters.mapLat, parameters.mapLng], parameters.mapZoom);
                        }
                        console.log("Reset texture and map");
                    }
                });
            }
            
            // Handle B/Y button for switching between texture and map dragging
            const bButtonComponent = motionController.getComponent("b-button") || motionController.getComponent("y-button");
            if (bButtonComponent) {
                bButtonComponent.onButtonStateChangedObservable.add((component) => {
                    if (component.pressed) {
                        isMapDragging = !isMapDragging;
                        console.log("Switched dragging mode:", isMapDragging ? "Map" : "Texture");
                    }
                });
            }
        });
    });
    
    // Update dragging in render loop
    engine.runRenderLoop(function() {
        if (isDragging && lastControllerPosition && xrHelper.input.controllers.length > 0) {
            const controller = xrHelper.input.controllers[0];
            if (controller && controller.pointer) {
                const currentPosition = controller.pointer.position;
                const deltaX = currentPosition.x - lastControllerPosition.x;
                const deltaY = currentPosition.y - lastControllerPosition.y;
                
                if (isMapDragging && window.leafletMap) {
                    // Apply movement to map
                    const mapSensitivity = 10.0;
                    parameters.mapLat = mapDragStart.lat - (deltaY * mapSensitivity);
                    parameters.mapLng = mapDragStart.lng + (deltaX * mapSensitivity);
                    
                    // Clamp values
                    parameters.mapLat = Math.max(-90, Math.min(90, parameters.mapLat));
                    parameters.mapLng = Math.max(-180, Math.min(180, parameters.mapLng));
                    
                    window.leafletMap.setView([parameters.mapLat, parameters.mapLng], parameters.mapZoom);
                    if (window.mapMarker) {
                        window.mapMarker.setLatLng([parameters.mapLat, parameters.mapLng]);
                    }
                } else {
                    // Apply movement to texture offset
                    const sensitivity = 2.0;
                    parameters.textureOffsetX = dragStartPosition.offsetX + (deltaX * sensitivity);
                    parameters.textureOffsetY = dragStartPosition.offsetY + (deltaY * sensitivity);
                    updateTextureTransform();
                }
            }
        }
    });
}

// HtmlTexture converts a HTML DOM element into a texture using html2canvas
class HtmlTexture extends BABYLON.DynamicTexture {
    constructor(domElement, scene) {
        super("HtmlTexture", html2canvas(domElement), scene);
        this.domElement = domElement;

        // Create an observer on the DOM, and run html2canvas update in the next loop
        const observer = new MutationObserver(() => {

            if (!this.scheduleUpdate) {
                // For map updates, use longer delay to allow tiles to load
                const delay = this.domElement.querySelector('#mapContainer') ? 100 : 16;
                this.scheduleUpdate = setTimeout(() => this.update(), delay);
            }

        });

        const config = { attributes: true, childList: true, subtree: true, characterData: true };
        observer.observe(domElement, config);

        this.observer = observer;
        
        // Set up periodic updates for dynamic content like maps
        this.periodicUpdate = setInterval(() => {
            if (this.domElement.querySelector('#mapContainer')) {
                this.update();
            }
        }, 500); // Update every 500ms for map content
    }

    get width() {
        return this._canvas.width;
    }

    get height() {
        return this._canvas.height;
    }

    update() {
        html2canvas(this.domElement);
        super.update()
        this.scheduleUpdate = null;
    }
    
    dispose() {
        super.dispose();
        if (this.observer) {
            this.observer.disconnect();
        }
        if (this.periodicUpdate) {
            clearInterval(this.periodicUpdate);
        }
    }
}

// creates a plane mesh and material with an attached HtmlTexture
// handles events for HTML interactions
class HtmlMesh { // TODO: derive from mesh class?
    constructor(domElement, scene) {
        this.domElement = domElement;

        // create HTML texture
        this.texture = new HtmlTexture(domElement, scene);
        this.texture.hasAlpha = true;

        // create plane
        this.mesh = BABYLON.MeshBuilder.CreatePlane("plane", { height: 5, width: 5 });
        this.material = new BABYLON.StandardMaterial("Mat", scene);

        // create material
        this.material.diffuseTexture = this.texture;
        this.material.useAlphaFromDiffuseTexture = true;
        this.material.backFaceCulling = false; // Allow viewing from both sides
        this.mesh.material = this.material;

        // remember to update or you will get NOTHING :)
        this.texture.update();

        // setup actions
        this.mesh.actionManager = new BABYLON.ActionManager(scene);

        // mousedown event on OnPickDownTrigger action
        this.mesh.actionManager.registerAction(
            new BABYLON.ExecuteCodeAction(
                {
                    trigger: BABYLON.ActionManager.OnPickDownTrigger,
                },
                (evt) => {
                    const htmlCoords = evt.additionalData.getTextureCoordinates();
                    // XXX: y coordinates are inverted between browser and 3D
                    htmlevent(this.domElement, "mousedown", htmlCoords.x, 1 - htmlCoords.y);
                },
            )
        );

        // mouseup event on OnPickUpTrigger action
        this.mesh.actionManager.registerAction(
            new BABYLON.ExecuteCodeAction(
                {
                    trigger: BABYLON.ActionManager.OnPickUpTrigger,
                },
                (evt) => {
                    const htmlCoords = evt.additionalData.getTextureCoordinates();
                    // XXX: y coordinates are inverted between browser and 3D
                    htmlevent(this.domElement, "mouseup", htmlCoords.x, 1 - htmlCoords.y);
                },
            )
        );

        // click event on OnPickTrigger action
        this.mesh.actionManager.registerAction(
            new BABYLON.ExecuteCodeAction(
                {
                    trigger: BABYLON.ActionManager.OnPickTrigger,
                },
                (evt) => {
                    const htmlCoords = evt.additionalData.getTextureCoordinates();
                    // XXX: y coordinates are inverted between browser and 3D
                    htmlevent(this.domElement, "click", htmlCoords.x, 1 - htmlCoords.y);
                },
            )
        );

        // mousemove event on OnPointerOverTrigger action
        this.mesh.actionManager.registerAction(
            new BABYLON.ExecuteCodeAction(
                {
                    trigger: BABYLON.ActionManager.OnPointerOverTrigger,
                },
                (evt) => {
                    // XXX: additionalData is structured different for mousemove
                    const htmlCoords = evt.additionalData.pickResult.getTextureCoordinates();
                    // XXX: y coordinates are inverted between browser and 3D
                    htmlevent(this.domElement, "mousemove", htmlCoords.x, 1 - htmlCoords.y);
                },
            )
        );

        // if you set AbstractMesh.pointerOverDisableMeshTesting to
        // true, this trigger will be triggered every time you move the
        // mouse and you are still over the mesh 
        this.mesh.pointerOverDisableMeshTesting = true;
    }
}

// loads a js module
const loadScript = (FILE_URL, async = true, type = "text/javascript") => {
    return new Promise((resolve, reject) => {
        try {
            const scriptEle = document.createElement("script");
            scriptEle.type = type;
            scriptEle.async = async;
            scriptEle.src =FILE_URL;

            scriptEle.addEventListener("load", (ev) => {
                resolve({ status: true });
            });

            scriptEle.addEventListener("error", (ev) => {
                reject({
                    status: false,
                    message: `Failed to load the script ${FILE_URL}`
                });
            });

            document.body.appendChild(scriptEle);
        } catch (error) {
            reject(error);
        }
    });
};

// borrowed from three.js with very slight modifications
const canvases = new WeakMap();
function html2canvas(element) {

    // TODO: move to relevant code block below
    const range = document.createRange();

    function Clipper(context) {

        const clips = [];
        let isClipping = false;

        function doClip() {

            if (isClipping) {

                isClipping = false;
                context.restore();

            }

            if (clips.length === 0) return;

            let minX = - Infinity, minY = - Infinity;
            let maxX = Infinity, maxY = Infinity;

            for (let i = 0; i < clips.length; i++) {

                const clip = clips[i];

                minX = Math.max(minX, clip.x);
                minY = Math.max(minY, clip.y);
                maxX = Math.min(maxX, clip.x + clip.width);
                maxY = Math.min(maxY, clip.y + clip.height);

            }

            context.save();
            context.beginPath();
            context.rect(minX, minY, maxX - minX, maxY - minY);
            context.clip();

            isClipping = true;

        }

        return {

            add: function (clip) {

                clips.push(clip);
                doClip();

            },

            remove: function () {

                clips.pop();
                doClip();

            }

        };

    }

    function drawText(style, x, y, string) {

        if (string !== '') {

            if (style.textTransform === 'uppercase') {

                string = string.toUpperCase();

            }

            context.font = style.fontWeight + ' ' + style.fontSize + ' ' + style.fontFamily;
            context.textBaseline = 'top';
            context.fillStyle = style.color;
            context.fillText(string, x, y + parseFloat(style.fontSize) * 0.1);

        }

    }

    function buildRectPath(x, y, w, h, r) {

        if (w < 2 * r) r = w / 2;
        if (h < 2 * r) r = h / 2;

        context.beginPath();
        context.moveTo(x + r, y);
        context.arcTo(x + w, y, x + w, y + h, r);
        context.arcTo(x + w, y + h, x, y + h, r);
        context.arcTo(x, y + h, x, y, r);
        context.arcTo(x, y, x + w, y, r);
        context.closePath();

    }

    function drawBorder(style, which, x, y, width, height) {

        const borderWidth = style[which + 'Width'];
        const borderStyle = style[which + 'Style'];
        const borderColor = style[which + 'Color'];

        if (borderWidth !== '0px' && borderStyle !== 'none' && borderColor !== 'transparent' && borderColor !== 'rgba(0, 0, 0, 0)') {

            context.strokeStyle = borderColor;
            context.lineWidth = parseFloat(borderWidth);
            context.beginPath();
            context.moveTo(x, y);
            context.lineTo(x + width, y + height);
            context.stroke();

        }

    }

    function drawElement(element, style) {

        let x = 0, y = 0, width = 0, height = 0;

        if (element.nodeType === Node.TEXT_NODE) {

            // text

            range.selectNode(element);

            const rect = range.getBoundingClientRect();

            x = rect.left - offset.left - 0.5;
            y = rect.top - offset.top - 0.5;
            width = rect.width;
            height = rect.height;

            drawText(style, x, y, element.nodeValue.trim());

        } else if (element.nodeType === Node.COMMENT_NODE) {

            return;

        } else if (element instanceof HTMLCanvasElement) {

            // Canvas element
            if (element.style.display === 'none') return;

            const rect = element.getBoundingClientRect();

            x = rect.left - offset.left - 0.5;
            y = rect.top - offset.top - 0.5;
            width = rect.width;
            height = rect.height;

            context.save();
            try {
                // Draw the canvas content directly
                context.drawImage(element, x, y, width, height);
            } catch (e) {
                // If canvas drawing fails, draw a placeholder
                context.fillStyle = '#f0f0f0';
                context.fillRect(x, y, width, height);
                context.strokeStyle = '#ccc';
                context.strokeRect(x, y, width, height);
                
                // Add text indicating it's a map
                context.fillStyle = '#666';
                context.font = '12px Arial';
                context.textAlign = 'center';
                context.fillText('Interactive Map', x + width/2, y + height/2);
            }
            context.restore();

        } else if (element instanceof HTMLImageElement) {

            if (element.style.display === 'none') return;

            const rect = element.getBoundingClientRect();

            x = rect.left - offset.left - 0.5;
            y = rect.top - offset.top - 0.5;
            width = rect.width;
            height = rect.height;

            context.drawImage(element, x, y, width, height);

        } else {

            if (element.style.display === 'none') return;

            const rect = element.getBoundingClientRect();

            x = rect.left - offset.left - 0.5;
            y = rect.top - offset.top - 0.5;
            width = rect.width;
            height = rect.height;

            style = window.getComputedStyle(element);

            // Special handling for Leaflet map container
            if (element.classList && (element.classList.contains('leaflet-container') || element.id === 'mapContainer')) {
                // Draw map background
                context.fillStyle = '#a6cee3'; // Light blue for water
                context.fillRect(x, y, width, height);
                
                // Try to capture any canvas elements within the map
                const mapCanvases = element.querySelectorAll('canvas');
                mapCanvases.forEach(canvas => {
                    if (canvas.style.display !== 'none') {
                        try {
                            const canvasRect = canvas.getBoundingClientRect();
                            const canvasX = canvasRect.left - offset.left - 0.5;
                            const canvasY = canvasRect.top - offset.top - 0.5;
                            context.drawImage(canvas, canvasX, canvasY, canvas.width, canvas.height);
                        } catch (e) {
                            console.log('Could not draw map canvas:', e);
                        }
                    }
                });
                
                // Try to capture tile images
                const tileImages = element.querySelectorAll('img');
                tileImages.forEach(img => {
                    if (img.complete && img.naturalWidth > 0) {
                        try {
                            const imgRect = img.getBoundingClientRect();
                            const imgX = imgRect.left - offset.left - 0.5;
                            const imgY = imgRect.top - offset.top - 0.5;
                            context.drawImage(img, imgX, imgY, imgRect.width, imgRect.height);
                        } catch (e) {
                            console.log('Could not draw map tile:', e);
                        }
                    }
                });
                
                // Add map overlay text
                context.fillStyle = 'rgba(0,0,0,0.7)';
                context.fillRect(x + 5, y + height - 25, 100, 20);
                context.fillStyle = 'white';
                context.font = '10px Arial';
                context.fillText('Leaflet Map', x + 10, y + height - 10);
                
                return; // Skip normal element processing
            }

            // Get the border of the element used for fill and border

            buildRectPath(x, y, width, height, parseFloat(style.borderRadius));

            const backgroundColor = style.backgroundColor;

            if (backgroundColor !== 'transparent' && backgroundColor !== 'rgba(0, 0, 0, 0)') {

                context.fillStyle = backgroundColor;
                context.fill();

            }

            // If all the borders match then stroke the round rectangle

            const borders = ['borderTop', 'borderLeft', 'borderBottom', 'borderRight'];

            let match = true;
            let prevBorder = null;

            for (const border of borders) {

                if (prevBorder !== null) {

                    match = (style[border + 'Width'] === style[prevBorder + 'Width']) &&
                        (style[border + 'Color'] === style[prevBorder + 'Color']) &&
                        (style[border + 'Style'] === style[prevBorder + 'Style']);

                }

                if (match === false) break;

                prevBorder = border;

            }

            if (match === true) {

                // They all match so stroke the rectangle from before allows for border-radius

                const width = parseFloat(style.borderTopWidth);

                if (style.borderTopWidth !== '0px' && style.borderTopStyle !== 'none' && style.borderTopColor !== 'transparent' && style.borderTopColor !== 'rgba(0, 0, 0, 0)') {

                    context.strokeStyle = style.borderTopColor;
                    context.lineWidth = width;
                    context.stroke();

                }

            } else {

                // Otherwise draw individual borders

                drawBorder(style, 'borderTop', x, y, width, 0);
                drawBorder(style, 'borderLeft', x, y, 0, height);
                drawBorder(style, 'borderBottom', x, y + height, width, 0);
                drawBorder(style, 'borderRight', x + width, y, 0, height);

            }

            if (element instanceof HTMLInputElement) {

                let accentColor = style.accentColor;

                if (accentColor === undefined || accentColor === 'auto') accentColor = style.color;

                // TODO
                // color.set(accentColor);

                // const luminance = Math.sqrt(0.299 * (color.r ** 2) +
                // 0.587 * (color.g ** 2) + 0.114 * (color.b ** 2));
                const luminance = 0;
                const accentTextColor = luminance < 0.5 ? 'white' : '#111111';

                if (element.type === 'radio') {

                    buildRectPath(x, y, width, height, height);

                    context.fillStyle = 'white';
                    context.strokeStyle = accentColor;
                    context.lineWidth = 1;
                    context.fill();
                    context.stroke();

                    if (element.checked) {

                        buildRectPath(x + 2, y + 2, width - 4, height - 4, height);

                        context.fillStyle = accentColor;
                        context.strokeStyle = accentTextColor;
                        context.lineWidth = 2;
                        context.fill();
                        context.stroke();

                    }

                }

                if (element.type === 'checkbox') {

                    buildRectPath(x, y, width, height, 2);

                    context.fillStyle = element.checked ? accentColor : 'white';
                    context.strokeStyle = element.checked ? accentTextColor : accentColor;
                    context.lineWidth = 1;
                    context.stroke();
                    context.fill();

                    if (element.checked) {

                        const currentTextAlign = context.textAlign;

                        context.textAlign = 'center';

                        const properties = {
                            color: accentTextColor,
                            fontFamily: style.fontFamily,
                            fontSize: height + 'px',
                            fontWeight: 'bold'
                        };

                        drawText(properties, x + (width / 2), y, '✔');

                        context.textAlign = currentTextAlign;

                    }

                }

                if (element.type === 'range') {

                    const [min, max, value] = ['min', 'max', 'value'].map(property => parseFloat(element[property]));
                    const position = ((value - min) / (max - min)) * (width - height);

                    buildRectPath(x, y + (height / 4), width, height / 2, height / 4);
                    context.fillStyle = accentTextColor;
                    context.strokeStyle = accentColor;
                    context.lineWidth = 1;
                    context.fill();
                    context.stroke();

                    buildRectPath(x, y + (height / 4), position + (height / 2), height / 2, height / 4);
                    context.fillStyle = accentColor;
                    context.fill();

                    buildRectPath(x + position, y, height, height, height / 2);
                    context.fillStyle = accentColor;
                    context.fill();

                }

                if (element.type === 'color' || element.type === 'text' || element.type === 'number') {

                    clipper.add({ x: x, y: y, width: width, height: height });

                    drawText(style, x + parseInt(style.paddingLeft), y + parseInt(style.paddingTop), element.value);

                    clipper.remove();

                }

            }

        }

        /*
        // debug
        context.strokeStyle = '#' + Math.random().toString( 16 ).slice( - 3 );
        context.strokeRect( x - 0.5, y - 0.5, width + 1, height + 1 );
        */

        const isClipping = style.overflow === 'auto' || style.overflow === 'hidden';

        if (isClipping) clipper.add({ x: x, y: y, width: width, height: height });

        for (let i = 0; i < element.childNodes.length; i++) {

            drawElement(element.childNodes[i], style);

        }

        if (isClipping) clipper.remove();

    }

    const offset = element.getBoundingClientRect();

    let canvas = canvases.get(element);

    if (canvas === undefined) {

        canvas = document.createElement('canvas');
        canvas.width = offset.width;
        canvas.height = offset.height;
        console.log(`initial size: ${canvas.width}x${canvas.height}`)
        canvases.set(element, canvas);

    }

    const context = canvas.getContext('2d'/*, { alpha: false }*/);

    const clipper = new Clipper(context);

    // console.time( 'drawElement' );

    context.clearRect(0, 0, canvas.width, canvas.height);

    drawElement(element);

    // console.timeEnd( 'drawElement' );

    return canvas;
}

function htmlevent(element, event, x, y) {
    const mouseEventInit = {
        clientX: (x * element.offsetWidth) + element.offsetLeft,
        clientY: (y * element.offsetHeight) + element.offsetTop,
        view: element.ownerDocument.defaultView
    };

    const m = new MouseEvent(event, mouseEventInit);
    window.dispatchEvent(m);

    const rect = element.getBoundingClientRect();

    x = x * rect.width + rect.left;
    y = y * rect.height + rect.top;

    function traverse(element) {

        if (element.nodeType !== Node.TEXT_NODE && element.nodeType !== Node.COMMENT_NODE) {
            const rect = element.getBoundingClientRect();

            if (x > rect.left && x < rect.right && y > rect.top && y < rect.bottom) {
                element.dispatchEvent(new MouseEvent(event, mouseEventInit));

                if (element instanceof HTMLInputElement && element.type === 'range' && (event === 'mousedown' || event === 'click')) {
                    const [min, max] = ['min', 'max'].map(property => parseFloat(element[property]));

                    const width = rect.width;
                    const offsetX = x - rect.x;
                    const proportion = offsetX / width;
                    element.value = min + (max - min) * proportion;
                    element.dispatchEvent(new InputEvent('input', { bubbles: true }));
                }
            }

            for (let i = 0; i < element.childNodes.length; i++) {
                traverse(element.childNodes[i]);
            }
        }
    }

    traverse(element);
}
                window.initFunction = async function() {
                    
                    
                    
                    var asyncEngineCreation = async function() {
                        try {
                        return createDefaultEngine();
                        } catch(e) {
                        console.log("the available createEngine function failed. Creating the default engine instead");
                        return createDefaultEngine();
                        }
                    }

                    window.engine = await asyncEngineCreation();
                    
                    const engineOptions = window.engine.getCreationOptions?.();
                    if (!engineOptions || engineOptions.audioEngine !== false) {
                        
                    }
        if (!engine) throw 'engine should not be null.';
        startRenderLoop(engine, canvas);
        window.scene = createScene();};
        initFunction().then(() => {scene.then(returnedScene => { sceneToRender = returnedScene; });
        
                    });

                    // Resize
                    window.addEventListener("resize", function () {
                        engine.resize();
                    });
        </script>
    </body>
</html>
