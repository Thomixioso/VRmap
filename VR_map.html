<script>
    var canvas = document.getElementById("renderCanvas");

    var startRenderLoop = function (engine, canvas) {
        engine.runRenderLoop(function () {
            if (sceneToRender && sceneToRender.activeCamera) {
                sceneToRender.render();
            }
        });
    }

    var engine = null;
    var scene = null;
    var sceneToRender = null;
    var createDefaultEngine = function() { return new BABYLON.Engine(canvas, true, { preserveDrawingBuffer: true, stencil: true,  disableWebGL2Support: false}); };

    // =========================================================================
    // Hlavní funkce pro vytvoření scény (beze změny)
    // =========================================================================
    var createScene = async function () {
        const mapElement = document.getElementById('mapContainer');

        // Inicializace Leaflet mapy
        const map = L.map(mapElement, {
            preferCanvas: true,
            // DŮLEŽITÉ: Následující dvě volby mohou výrazně zlepšit interakci
            // Leaflet nebude používat CSS animace pro zoom, což je lepší pro html2canvas
            zoomAnimation: false,
            // Leaflet nebude používat CSS transformace pro posun, což je také lepší
            fadeAnimation: false,
            markerZoomAnimation: false,
        }).setView([50.0755, 14.4378], 5); // Oddálíme mapu pro lepší přehled

        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            maxZoom: 19,
            attribution: '&copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a>'
        }).addTo(map);

        L.marker([50.0755, 14.4378]).addTo(map).bindPopup('Praha');
        
        var scene = new BABYLON.Scene(engine);
        var camera = new BABYLON.FreeCamera("camera1", new BABYLON.Vector3(0, 5, -10), scene);
        camera.setTarget(BABYLON.Vector3.Zero());
        camera.attachControl(canvas, true);

        var light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, 1, 0), scene);
        light.intensity = 0.7;

        // Vytvoření 3D objektu (plochy) s texturou naší mapy
        const htmlMesh = new HtmlMesh(mapElement, scene);
        htmlMesh.mesh.scaling.y = 0.75;
        htmlMesh.mesh.position = new BABYLON.Vector3(0, 2, 0);

        const xrHelper = await scene.createDefaultXRExperienceAsync();

        return scene;
    };

    // =========================================================================
    // Nástroje a třídy (ZDE JSOU KLÍČOVÉ ÚPRAVY)
    // =========================================================================

    // UPRAVENÁ FUNKCE: Simuluje události myši na HTML elementu
    // Je zjednodušená a spolehlivější pro skryté elementy.
    function htmlevent(element, eventType, x, y, button = 0) {
        // Někdy se souřadnice mohou dostat mimo rozsah [0, 1], ořízneme je.
        x = Math.max(0, Math.min(1, x));
        y = Math.max(0, Math.min(1, y));

        const rect = element.getBoundingClientRect();
        const clientX = rect.left + x * rect.width;
        const clientY = rect.top + y * rect.height;

        const eventInit = {
            clientX: clientX,
            clientY: clientY,
            bubbles: true,
            cancelable: true,
            composed: true,
            view: window,
            button: button, // 0 = levé, 1 = střední, 2 = pravé
            buttons: button === 0 ? 1 : 0, // Indikuje, které tlačítko je stisknuté
        };

        // Vytvoříme a odešleme událost PŘÍMO na hlavní element.
        // Leaflet si sám najde správný vnitřní cíl.
        const event = new MouseEvent(eventType, eventInit);
        element.dispatchEvent(event);
    }

    // UPRAVENÁ TŘÍDA: HtmlTexture
    class HtmlTexture extends BABYLON.DynamicTexture {
        constructor(domElement, scene) {
            const tempCanvas = document.createElement("canvas");
            tempCanvas.width = domElement.clientWidth;
            tempCanvas.height = domElement.clientHeight;

            super("HtmlTexture", tempCanvas, scene, true);
            this.domElement = domElement;
            this._scene = scene;
            
            // Zkrátíme interval pro plynulejší pocit z posouvání
            this._updateInterval = setInterval(() => this.update(), 100); // 10x za sekundu
            console.log("HtmlTexture created. Updating every 100ms.");
        }

        async update() {
            try {
                const canvas = await html2canvas(this.domElement, {
                    useCORS: true,
                    logging: false,
                    // Důležité: Řekneme html2canvas, kde je element, i když je mimo obrazovku
                    x: this.domElement.offsetLeft,
                    y: this.domElement.offsetTop,
                    width: this.domElement.clientWidth,
                    height: this.domElement.clientHeight,
                    windowWidth: document.documentElement.scrollWidth,
                    windowHeight: document.documentElement.scrollHeight
                });
                const textureContext = this.getContext();
                textureContext.clearRect(0, 0, this.getSize().width, this.getSize().height);
                textureContext.drawImage(canvas, 0, 0);
                super.update();
            } catch (error) {
                console.error("html2canvas error:", error);
            }
        }
        
        dispose() {
            clearInterval(this._updateInterval);
            super.dispose();
        }
    }


    // VÝRAZNĚ UPRAVENÁ TŘÍDA: HtmlMesh
    // Tato třída nyní obsahuje robustnější logiku pro zpracování interakcí.
    class HtmlMesh {
        constructor(domElement, scene) {
            this.domElement = domElement;
            this.texture = new HtmlTexture(domElement, scene);
            this.texture.hasAlpha = true;

            this.mesh = BABYLON.MeshBuilder.CreatePlane("htmlPlane", { height: 5, width: 5 }, scene);
            this.material = new BABYLON.StandardMaterial("htmlMat", scene);
            this.material.diffuseTexture = this.texture;
            this.material.emissiveColor = new BABYLON.Color3(0.2, 0.2, 0.2);
            this.material.backFaceCulling = false;
            this.mesh.material = this.material;

            let isDragging = false;

            const getHTMLCoords = (pickResult) => {
                if (!pickResult || !pickResult.hit) return null;
                const htmlCoords = pickResult.getTextureCoordinates();
                if (!htmlCoords) return null;
                return { x: htmlCoords.x, y: 1 - htmlCoords.y };
            };

            scene.onPointerObservable.add((pointerInfo) => {
                // Zpracováváme pouze interakce s naší plochou
                if (pointerInfo.pickInfo?.pickedMesh !== this.mesh) {
                    // Pokud se myš pohnula mimo a my jsme táhli, ukončíme to
                    if (isDragging) {
                        isDragging = false;
                        htmlevent(this.domElement, "mouseup", 0, 0); // Posíláme obecný mouseup
                        htmlevent(this.domElement, "mouseleave", 0, 0);
                    }
                    return;
                }

                const coords = getHTMLCoords(pointerInfo.pickInfo);
                if (!coords) return;
                
                switch (pointerInfo.type) {
                    case BABYLON.PointerEventTypes.POINTERDOWN:
                        isDragging = true;
                        htmlevent(this.domElement, "mousedown", coords.x, coords.y, 0);
                        break;

                    case BABYLON.PointerEventTypes.POINTERUP:
                        if (isDragging) {
                            isDragging = false;
                            htmlevent(this.domElement, "mouseup", coords.x, coords.y, 0);
                        }
                        break;

                    case BABYLON.PointerEventTypes.POINTERMOVE:
                        // Posíláme událost `mousemove` vždy, Leaflet ji potřebuje pro hover efekty
                        htmlevent(this.domElement, "mousemove", coords.x, coords.y, isDragging ? 0 : -1);
                        break;
                    
                    case BABYLON.PointerEventTypes.POINTERWHEEL:
                        // Ponecháno pro zoom kolečkem
                        const event = new WheelEvent('wheel', {
                            deltaY: pointerInfo.event.deltaY,
                            deltaX: pointerInfo.event.deltaX,
                            clientX: coords.x * this.domElement.clientWidth,
                            clientY: coords.y * this.domElement.clientHeight,
                            bubbles: true,
                            cancelable: true
                        });
                        this.domElement.dispatchEvent(event);
                        pointerInfo.event.preventDefault();
                        break;
                }
            });
        }
    }
            
    // Startovací logika (beze změny)
    var initFunction = async function() {
        var asyncEngineCreation = async function() {
            try {
                return createDefaultEngine();
            } catch(e) {
                console.log("the available createEngine function failed. Creating the default engine instead");
                return createDefaultEngine();
            }
        }
        engine = await asyncEngineCreation();
        if (!engine) throw 'engine should not be null.';
        startRenderLoop(engine, canvas);
        scene = await createScene();
        sceneToRender = scene;
    };

    initFunction().then(() => {
        // Scéna je připravena
    });
</script>
