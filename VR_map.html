<!DOCTYPE html>
<html lang="cs">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VR ≈Ωiv√° Mapa - Funkƒçn√≠ verze</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #000;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
        }
        
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            z-index: 100;
            background: rgba(0,0,0,0.9);
            padding: 15px;
            border-radius: 8px;
            max-width: 350px;
        }
        
        #vrButton {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 100;
        }
        
        #controls {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 100;
            background: rgba(0,0,0,0.9);
            padding: 15px;
            border-radius: 8px;
            color: white;
            min-width: 200px;
        }
        
        .back-button {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 101;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            text-decoration: none;
            padding: 12px 24px;
            border-radius: 25px;
            font-weight: 500;
            transition: all 0.3s ease;
            border: 1px solid rgba(255, 255, 255, 0.3);
        }
        
        .back-button:hover {
            background: rgba(255, 255, 255, 0.1);
            transform: translateX(-50%) translateY(-2px);
        }
        
        canvas {
            display: block;
        }
        
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 18px;
            text-align: center;
        }
        
        button {
            background: #4a90e2;
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            margin: 3px;
            font-size: 12px;
        }
        
        button:hover {
            background: #357abd;
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-button">‚Üê Zpƒõt na v√Ωbƒõr</a>
    
    <div id="info">
        <h3>üåç VR ≈Ωiv√° Mapa</h3>
        <p><strong>Desktop:</strong></p>
        <ul style="font-size: 12px; margin: 5px 0; padding-left: 15px;">
            <li>WASD = posun mapy (GPS)</li>
            <li>Q/E = zoom</li>
            <li>≈†ipky = ch≈Øze kolem canvasu</li>
            <li>Klik = p≈ôidat marker</li>
        </ul>
        <p><strong>VR (NOV√â STABILN√ç):</strong></p>
        <ul style="font-size: 12px; margin: 5px 0; padding-left: 15px;">
            <li><strong>Prav√Ω controller:</strong></li>
            <li>&nbsp;&nbsp;‚Ä¢ Trigger = laser drag mapa (plynul√© tiles)</li>
            <li><strong>Lev√Ω controller:</strong></li>
            <li>&nbsp;&nbsp;‚Ä¢ Joystick = ch≈Øze kolem canvasu</li>
            <li>&nbsp;&nbsp;‚Ä¢ X tlaƒç√≠tko = zoom IN</li>
            <li>&nbsp;&nbsp;‚Ä¢ Y tlaƒç√≠tko = zoom OUT</li>
        </ul>
        <div id="coords">GPS: 50.075, 14.438</div>
        <div id="zoomInfo">Zoom: 10</div>
        <div id="status">Inicializuji...</div>
    </div>
    
    <div id="controls">
        <h4>üéÆ Ovl√°d√°n√≠</h4>
        <div>
            <button onclick="jumpTo(50.075, 14.438)">üèõÔ∏è Praha</button>
            <button onclick="jumpTo(51.507, -0.128)">üá¨üáß Lond√Ωn</button>
        </div>
        <div>
            <button onclick="jumpTo(40.713, -74.006)">üóΩ NYC</button>
            <button onclick="jumpTo(35.676, 139.650)">üóæ Tokio</button>
        </div>
        <div>
            <button onclick="clearMarkers()">üóëÔ∏è Sma≈æ markery</button>
        </div>
    </div>
    
    <div class="loading" id="loading">üöÄ Naƒç√≠t√°m VR mapu...</div>
    <div id="vrButton"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // === GLOB√ÅLN√ç PROMƒöNN√â ===
        let scene, camera, renderer, mapGroup, userGroup;
        let controller1, controller2;
        let raycaster, mouse = new THREE.Vector2();
        let markers = [];
        
        // === MAPA STAV ===
        let mapCenter = { lat: 50.075, lng: 14.438 };
        let mapZoom = 10;
        let mapPlane;
        
        // === VR STAV ===
        let isDragging = false;
        let dragStartPosition = null;
        let dragStartMapCenter = null;
        let dragController = null;
        let mapOffset = { x: 0, y: 0 };
        
        // === VR BUTTON STATES ===
        let vrButtonStates = new Map();
        let lastTileLoad = 0;
        
        // === VR BUTTON HACK ===
        function createSimpleVRButton(renderer) {
            const button = document.createElement('button');
            button.style.position = 'absolute';
            button.style.bottom = '20px';
            button.style.padding = '12px 20px';
            button.style.border = 'none';
            button.style.borderRadius = '6px';
            button.style.background = '#4a90e2';
            button.style.color = 'white';
            button.style.cursor = 'pointer';
            button.style.fontSize = '14px';
            button.textContent = 'Enter VR';
            
            if (navigator.xr) {
                button.onclick = async () => {
                    if (renderer.xr.isPresenting) {
                        renderer.xr.getSession().end();
                    } else {
                        try {
                            console.log('ü•Ω Po≈æ√°d√°m o VR session...');
                            
                            // Zkus r≈Øzn√© reference spaces s fallbackem
                            const sessionInit = {
                                requiredFeatures: [],
                                optionalFeatures: ['local-floor', 'bounded-floor']
                            };
                            
                            const session = await navigator.xr.requestSession('immersive-vr', sessionInit);
                            
                            console.log('‚úÖ VR session vytvo≈ôena');
                            
                            // Zkus naj√≠t nejlep≈°√≠ reference space
                            let referenceSpace;
                            try {
                                referenceSpace = await session.requestReferenceSpace('local-floor');
                                console.log('‚úÖ Pou≈æ√≠v√°m local-floor reference space');
                            } catch (e) {
                                console.log('‚ö†Ô∏è local-floor nepodporov√°n, zkou≈°√≠m local...');
                                try {
                                    referenceSpace = await session.requestReferenceSpace('local');
                                    console.log('‚úÖ Pou≈æ√≠v√°m local reference space');
                                } catch (e2) {
                                    console.log('‚ö†Ô∏è local nepodporov√°n, pou≈æ√≠v√°m viewer...');
                                    referenceSpace = await session.requestReferenceSpace('viewer');
                                    console.log('‚úÖ Pou≈æ√≠v√°m viewer reference space');
                                }
                            }
                            
                            renderer.xr.setSession(session);
                            updateStatus('‚úÖ VR aktivn√≠');
                            
                        } catch (error) {
                            console.error('‚ùå VR session failed:', error);
                            updateStatus('‚ùå VR nepodporov√°no nebo zam√≠tnuto');
                        }
                    }
                };
            } else {
                button.textContent = 'VR Nedostupn√©';
                button.disabled = true;
                button.style.background = '#666';
            }
            
            return button;
        }
        
        // === INICIALIZACE ===
        function init() {
            console.log('üöÄ Inicializuji jednoduchou VR mapu bez import≈Ø...');
            
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            
            // User group pro VR locomotion
            userGroup = new THREE.Group();
            scene.add(userGroup);
            console.log('‚úÖ userGroup vytvo≈ôena:', userGroup);
            
            // Camera v lidsk√©m mƒõ≈ô√≠tku - 15m od canvasu
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 100);
            camera.position.set(0, 1.7, 15); // V√Ω≈°ka oƒç√≠ 1.7m, 15m od canvasu
            camera.lookAt(0, 1.7, 0); // D√≠v√°me se na st≈ôed canvasu ve v√Ω≈°ce oƒç√≠
            userGroup.add(camera);
            console.log('‚úÖ Camera v lidsk√©m mƒõ≈ô√≠tku na pozici:', camera.position);
            
            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.xr.enabled = true;
            document.body.appendChild(renderer.domElement);
            console.log('‚úÖ Renderer vytvo≈ôen');
            
            // Simple VR Button
            document.getElementById('vrButton').appendChild(createSimpleVRButton(renderer));
            
            // WebXR session event monitoring
            renderer.xr.addEventListener('sessionstart', () => {
                console.log('ü•Ω WebXR session started');
                updateStatus('ü•Ω VR session aktivn√≠');
            });
            
            renderer.xr.addEventListener('sessionend', () => {
                console.log('ü•Ω WebXR session ended');
                updateStatus('ü•Ω VR session ukonƒçena');
            });
            
            setupLighting();
            createSimpleMap();
            setupVRControllers();
            setupDesktopControls();
            
            // Inicializuj VR button states
            vrButtonStates.set('left_x', false);
            vrButtonStates.set('left_y', false);
            lastTileLoad = Date.now();
            
            // Animation loop
            renderer.setAnimationLoop(animate);
            
            document.getElementById('loading').style.display = 'none';
            updateStatus('‚úÖ Jednoduch√° mapa p≈ôipravena');
        }
        
        // === OSVƒöTLEN√ç ===
        function setupLighting() {
            const ambientLight = new THREE.AmbientLight(0x404040, 0.8);
            scene.add(ambientLight);
            
            const sunLight = new THREE.DirectionalLight(0xffffff, 1.0);
            sunLight.position.set(50, 100, 50);
            scene.add(sunLight);
        }
        
        // === MAPA V RE√ÅLN√âM Mƒö≈ò√çTKU ===
        function createSimpleMap() {
            mapGroup = new THREE.Group();
            scene.add(mapGroup);
            
            // Grid podklad v lidsk√©m mƒõ≈ô√≠tku (10x10m)
            const gridHelper = new THREE.GridHelper(10, 10, 0x444444, 0x444444);
            gridHelper.rotation.x = Math.PI / 2; // Vertik√°lnƒõ
            gridHelper.position.set(0, 1.7, -0.1); // Ve v√Ω≈°ce oƒç√≠, m√≠rnƒõ za canvasem
            mapGroup.add(gridHelper);
            
            // Hlavn√≠ canvas 10x10 metr≈Ø
            const geometry = new THREE.PlaneGeometry(10, 10); // 10x10 metr≈Ø
            const material = new THREE.MeshBasicMaterial({ 
                color: 0x90EE90,
                transparent: true,
                opacity: 0.9
            });
            
            mapPlane = new THREE.Mesh(geometry, material);
            mapPlane.position.set(0, 1.7, 0); // St≈ôed ve v√Ω≈°ce oƒç√≠, p≈ô√≠mo p≈ôed kamerou
            mapPlane.name = 'mapPlane';
            mapGroup.add(mapPlane);
            
            // R√°m kolem canvasu
            addCanvasFrame();
            
            // Podlaha pro orientaci
            addFloor();
            
            loadCenterTile();
            
            console.log('‚úÖ 10x10m canvas vytvo≈ôen 15m od kamery');
        }
        
        function addCanvasFrame() {
            // ƒåern√Ω r√°m kolem 10x10m canvasu
            const frameThickness = 0.1;
            const frameDepth = 0.05;
            
            // 4 strany r√°mu
            const frameGeometry = new THREE.BoxGeometry(10.2, frameThickness, frameDepth);
            const frameMaterial = new THREE.MeshBasicMaterial({ color: 0x222222 });
            
            // Horn√≠ r√°m
            const topFrame = new THREE.Mesh(frameGeometry, frameMaterial);
            topFrame.position.set(0, 1.7 + 5.1, 0.025);
            mapGroup.add(topFrame);
            
            // Spodn√≠ r√°m
            const bottomFrame = new THREE.Mesh(frameGeometry, frameMaterial);
            bottomFrame.position.set(0, 1.7 - 5.1, 0.025);
            mapGroup.add(bottomFrame);
            
            // Lev√Ω a prav√Ω r√°m
            const sideFrameGeometry = new THREE.BoxGeometry(frameThickness, 10.2, frameDepth);
            
            const leftFrame = new THREE.Mesh(sideFrameGeometry, frameMaterial);
            leftFrame.position.set(-5.1, 1.7, 0.025);
            mapGroup.add(leftFrame);
            
            const rightFrame = new THREE.Mesh(sideFrameGeometry, frameMaterial);
            rightFrame.position.set(5.1, 1.7, 0.025);
            mapGroup.add(rightFrame);
            
            console.log('‚úÖ R√°m kolem canvasu p≈ôid√°n');
        }
        
        function addFloor() {
            // Jednoduch√° podlaha pro orientaci
            const floorGeometry = new THREE.PlaneGeometry(30, 30);
            const floorMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x333333,
                transparent: true,
                opacity: 0.3
            });
            
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2; // Horizont√°lnƒõ
            floor.position.y = 0;
            scene.add(floor);
            
            console.log('‚úÖ Podlaha p≈ôid√°na');
        }
        
        function loadCenterTile() {
            const zoom = Math.floor(mapZoom);
            const tileX = Math.floor((mapCenter.lng + 180) / 360 * Math.pow(2, zoom));
            const tileY = Math.floor((1 - Math.log(Math.tan(mapCenter.lat * Math.PI / 180) + 1 / Math.cos(mapCenter.lat * Math.PI / 180)) / Math.PI) / 2 * Math.pow(2, zoom));
            
            // ArcGIS satelitn√≠ mapa (nejspolehlivƒõj≈°√≠ pro plynul√© naƒç√≠t√°n√≠)
            const tileUrl = `https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/${zoom}/${tileY}/${tileX}`;
            
            console.log(`üì° Rychl√© naƒç√≠t√°n√≠ tile: ${zoom}/${tileX}/${tileY}`);
            
            const loader = new THREE.TextureLoader();
            loader.setCrossOrigin('anonymous');
            
            // Timeout pro rychlej≈°√≠ naƒç√≠t√°n√≠
            const startTime = Date.now();
            
            loader.load(
                tileUrl,
                (texture) => {
                    const loadTime = Date.now() - startTime;
                    mapPlane.material.map = texture;
                    mapPlane.material.needsUpdate = true;
                    updateStatus(`‚úÖ Tile ${loadTime}ms: ${mapCenter.lat.toFixed(3)}, ${mapCenter.lng.toFixed(3)}`);
                    console.log(`‚úÖ Tile naƒçten za ${loadTime}ms`);
                },
                (progress) => {
                    // Progress tracking pro debug
                    if (progress.total > 0) {
                        const percent = (progress.loaded / progress.total * 100).toFixed(0);
                        console.log(`üì° Loading: ${percent}%`);
                    }
                },
                (error) => {
                    console.warn('‚ùå ArcGIS selhal, zkou≈°√≠m OSM...');
                    
                    // Rychl√Ω fallback na OpenStreetMap
                    const osmUrl = `https://tile.openstreetmap.org/${zoom}/${tileX}/${tileY}.png`;
                    loader.load(
                        osmUrl,
                        (texture) => {
                            mapPlane.material.map = texture;
                            mapPlane.material.needsUpdate = true;
                            updateStatus(`‚úÖ OSM tile: ${mapCenter.lat.toFixed(3)}, ${mapCenter.lng.toFixed(3)}`);
                            console.log('‚úÖ OSM fallback √∫spƒõ≈°n√Ω');
                        },
                        undefined,
                        (error2) => {
                            console.error('‚ùå V≈°echny tile servery selhaly');
                            updateStatus('‚ùå Tile loading failed');
                        }
                    );
                }
            );
        }
        
        // === VR OVLADAƒåE (NOV√ù STABILN√ç SYST√âM) ===
        function setupVRControllers() {
            console.log('üéÆ Nastavuji stabiln√≠ VR ovladaƒçe...');
            
            if (!userGroup) {
                console.error('‚ùå userGroup is still undefined!');
                return;
            }
            
            raycaster = new THREE.Raycaster();
            
            // Controller 0 (PRAV√ù) - Pro trigger drag
            controller1 = renderer.xr.getController(0);
            if (controller1) {
                controller1.addEventListener('selectstart', () => startDrag(0));
                controller1.addEventListener('selectend', () => stopDrag(0));
                userGroup.add(controller1);
                addLaser(controller1, 0xff0000); // ƒåerven√Ω laser
                console.log('‚úÖ Prav√Ω controller (drag)');
            }
            
            // Controller 1 (LEV√ù) - Pro pohyb a tlaƒç√≠tka
            controller2 = renderer.xr.getController(1);
            if (controller2) {
                userGroup.add(controller2);
                addLaser(controller2, 0x00ff00); // Zelen√Ω laser
                console.log('‚úÖ Lev√Ω controller (pohyb + tlaƒç√≠tka)');
            }
            
            console.log('‚úÖ Stabiln√≠ VR Controllers setup dokonƒçen');
        }
        
        function addLaser(controller, color) {
            const geometry = new THREE.BufferGeometry().setFromPoints([
                new THREE.Vector3(0, 0, 0),
                new THREE.Vector3(0, 0, -1)
            ]);
            const line = new THREE.Line(geometry, new THREE.LineBasicMaterial({ color: color }));
            line.scale.z = 15;
            controller.add(line);
        }
        
        // === VR EVENTY (NOV√â) ===
        function startDrag(controllerIndex) {
            console.log(`üéØ Zaƒç√°tek drag s controllerem ${controllerIndex}`);
            
            if (controllerIndex === 0 && controller1) { // Pouze prav√Ω controller
                isDragging = true;
                dragController = controller1;
                dragStartPosition = controller1.position.clone();
                dragStartMapCenter = { lat: mapCenter.lat, lng: mapCenter.lng };
                mapOffset = { x: 0, y: 0 };
                
                updateStatus('üéØ Drag mapa - laser pointer');
                console.log('‚úÖ Drag aktivn√≠');
            }
        }
        
        function stopDrag(controllerIndex) {
            console.log(`üéØ Konec drag s controllerem ${controllerIndex}`);
            
            if (isDragging && controllerIndex === 0) {
                // P≈ôevod vizu√°ln√≠ho offsetu na GPS zmƒõnu
                const dragToGPS = 0.005; // Jemnƒõj≈°√≠ p≈ôevod
                mapCenter.lng -= mapOffset.x * dragToGPS;
                mapCenter.lat += mapOffset.y * dragToGPS;
                
                // Clamp coordinates
                mapCenter.lat = Math.max(-85, Math.min(85, mapCenter.lat));
                mapCenter.lng = Math.max(-180, Math.min(180, mapCenter.lng));
                
                // Reset vizu√°ln√≠ pozice
                mapGroup.position.x = 0;
                mapGroup.position.y = 0;
                mapOffset = { x: 0, y: 0 };
                
                isDragging = false;
                dragController = null;
                dragStartPosition = null;
                dragStartMapCenter = null;
                
                // Naƒçti nov√Ω tile
                loadCenterTile();
                updateStatus('‚úÖ Drag ukonƒçen - nov√Ω tile');
                console.log('‚úÖ Drag ukonƒçen, GPS aktualizov√°no');
            }
        }
        
        // === VR INPUT (NOV√ù STABILN√ç SYST√âM) ===
        function updateVRInput() {
            if (!renderer.xr.isPresenting) return;
            
            const session = renderer.xr.getSession();
            if (!session || !session.inputSources) return;
            
            // 1. PRAV√ù CONTROLLER - LASER DRAG
            handleRightControllerDrag();
            
            // 2. LEV√ù CONTROLLER - POHYB A TLAƒå√çTKA
            handleLeftControllerInput(session);
        }
        
        function handleRightControllerDrag() {
            // Plynul√Ω drag s okam≈æit√Ωm vizu√°ln√≠m feedbackem
            if (isDragging && dragController && dragStartPosition && dragStartMapCenter) {
                const currentPosition = dragController.position.clone();
                const deltaPosition = currentPosition.sub(dragStartPosition);
                
                const dragSensitivity = 8; // Optimalizovan√° citlivost pro 10x10m canvas
                mapOffset.x = deltaPosition.x * dragSensitivity;
                mapOffset.y = deltaPosition.y * dragSensitivity;
                
                // Okam≈æitƒõ posu≈à mapu pro vizu√°ln√≠ feedback
                mapGroup.position.x = mapOffset.x;
                mapGroup.position.y = mapOffset.y;
                
                // Plynul√© naƒç√≠t√°n√≠ tiles bƒõhem drag (ka≈æd√Ωch 500ms)
                const now = Date.now();
                if (now - lastTileLoad > 500) {
                    const tempLat = dragStartMapCenter.lat - deltaPosition.y * 0.005;
                    const tempLng = dragStartMapCenter.lng + deltaPosition.x * 0.005;
                    
                    // Clamp temp coordinates
                    const clampedLat = Math.max(-85, Math.min(85, tempLat));
                    const clampedLng = Math.max(-180, Math.min(180, tempLng));
                    
                    // Doƒçasnƒõ aktualizuj mapCenter pro naƒçten√≠ nov√©ho tile
                    const originalLat = mapCenter.lat;
                    const originalLng = mapCenter.lng;
                    mapCenter.lat = clampedLat;
                    mapCenter.lng = clampedLng;
                    
                    loadCenterTile();
                    lastTileLoad = now;
                    
                    // Vra≈• p≈Øvodn√≠ hodnoty (budou se aktualizovat a≈æ po konci drag)
                    mapCenter.lat = originalLat;
                    mapCenter.lng = originalLng;
                    
                    console.log(`üîÑ Plynul√© naƒç√≠t√°n√≠ bƒõhem drag: ${clampedLat.toFixed(3)}, ${clampedLng.toFixed(3)}`);
                }
                
                console.log(`üéØ Drag: offset(${mapOffset.x.toFixed(2)}, ${mapOffset.y.toFixed(2)})`);
            }
        }
        
        function handleLeftControllerInput(session) {
            // Najdi lev√Ω controller (index 1)
            const leftInputSource = session.inputSources[1];
            if (!leftInputSource || !leftInputSource.gamepad) return;
            
            const gamepad = leftInputSource.gamepad;
            
            // A. LEV√ù JOYSTICK - POHYB VE SC√âNƒö
            if (gamepad.axes && gamepad.axes.length >= 2) {
                const joystickX = gamepad.axes[0]; // Lev√Ω joystick X
                const joystickY = gamepad.axes[1]; // Lev√Ω joystick Y
                
                if (Math.abs(joystickX) > 0.1 || Math.abs(joystickY) > 0.1) {
                    const walkSpeed = 0.08; // Realistick√° rychlost ch≈Øze
                    
                    // Pohyb podle smƒõru kamery
                    const forward = new THREE.Vector3(0, 0, -1);
                    forward.applyQuaternion(camera.quaternion);
                    forward.y = 0; // Jen horizont√°ln√≠ pohyb
                    forward.normalize();
                    
                    const right = new THREE.Vector3(1, 0, 0);
                    right.applyQuaternion(camera.quaternion);
                    right.y = 0;
                    right.normalize();
                    
                    // Aplikuj pohyb
                    const movement = new THREE.Vector3();
                    movement.add(forward.clone().multiplyScalar(joystickY * walkSpeed));
                    movement.add(right.clone().multiplyScalar(joystickX * walkSpeed));
                    
                    userGroup.position.add(movement);
                    
                    // Omez pohyb kolem canvasu
                    userGroup.position.x = Math.max(-10, Math.min(10, userGroup.position.x));
                    userGroup.position.z = Math.max(5, Math.min(25, userGroup.position.z));
                    
                    console.log(`üö∂ Pohyb: joystick(${joystickX.toFixed(2)}, ${joystickY.toFixed(2)}) -> pozice(${userGroup.position.x.toFixed(1)}m, ${userGroup.position.z.toFixed(1)}m)`);
                }
            }
            
            // B. X TLAƒå√çTKO - ZOOM IN
            if (gamepad.buttons && gamepad.buttons[4]) { // X button
                const xPressed = gamepad.buttons[4].pressed;
                const xKey = 'left_x';
                
                if (xPressed && !vrButtonStates.get(xKey)) {
                    mapZoom = Math.min(18, mapZoom + 0.5);
                    loadCenterTile();
                    updateStatus(`üîç Zoom IN: ${mapZoom.toFixed(1)}`);
                    console.log(`üîç X button - Zoom IN: ${mapZoom.toFixed(1)}`);
                }
                vrButtonStates.set(xKey, xPressed);
            }
            
            // C. Y TLAƒå√çTKO - ZOOM OUT
            if (gamepad.buttons && gamepad.buttons[5]) { // Y button
                const yPressed = gamepad.buttons[5].pressed;
                const yKey = 'left_y';
                
                if (yPressed && !vrButtonStates.get(yKey)) {
                    mapZoom = Math.max(1, mapZoom - 0.5);
                    loadCenterTile();
                    updateStatus(`üîç Zoom OUT: ${mapZoom.toFixed(1)}`);
                    console.log(`üîç Y button - Zoom OUT: ${mapZoom.toFixed(1)}`);
                }
                vrButtonStates.set(yKey, yPressed);
            }
        }
        
        // === DESKTOP OVL√ÅD√ÅN√ç PRO RE√ÅLN√â Mƒö≈ò√çTKO ===
        function setupDesktopControls() {
            const keys = {};
            
            document.addEventListener('keydown', (e) => {
                keys[e.key.toLowerCase()] = true;
            });
            
            document.addEventListener('keyup', (e) => {
                keys[e.key.toLowerCase()] = false;
            });
            
            function updateDesktopMovement() {
                const mapMoveSpeed = 0.01; // Posun GPS
                const walkSpeed = 0.1; // Realistick√° rychlost ch≈Øze
                
                // WASD = posun mapy (GPS)
                if (keys['w']) {
                    mapCenter.lat += mapMoveSpeed;
                    loadCenterTile();
                }
                if (keys['s']) {
                    mapCenter.lat -= mapMoveSpeed;
                    loadCenterTile();
                }
                if (keys['a']) {
                    mapCenter.lng -= mapMoveSpeed;
                    loadCenterTile();
                }
                if (keys['d']) {
                    mapCenter.lng += mapMoveSpeed;
                    loadCenterTile();
                }
                
                // Q/E = zoom
                if (keys['q'] && mapZoom < 18) {
                    mapZoom += 0.1;
                    loadCenterTile();
                }
                if (keys['e'] && mapZoom > 1) {
                    mapZoom -= 0.1;
                    loadCenterTile();
                }
                
                // ≈†ipky = realistick√Ω pohyb kamery (jako ch≈Øze)
                if (keys['arrowup']) {
                    userGroup.position.z -= walkSpeed; // Bl√≠≈æ k canvasu
                    userGroup.position.z = Math.max(5, userGroup.position.z);
                    console.log(`üì∑ Vzd√°lenost od canvasu: ${userGroup.position.z.toFixed(1)}m`);
                }
                if (keys['arrowdown']) {
                    userGroup.position.z += walkSpeed; // D√°l od canvasu
                    userGroup.position.z = Math.min(25, userGroup.position.z);
                    console.log(`üì∑ Vzd√°lenost od canvasu: ${userGroup.position.z.toFixed(1)}m`);
                }
                if (keys['arrowleft']) {
                    userGroup.position.x -= walkSpeed; // Vlevo
                    userGroup.position.x = Math.max(-10, userGroup.position.x);
                    console.log(`üì∑ Pozice X: ${userGroup.position.x.toFixed(1)}m`);
                }
                if (keys['arrowright']) {
                    userGroup.position.x += walkSpeed; // Vpravo
                    userGroup.position.x = Math.min(10, userGroup.position.x);
                    console.log(`üì∑ Pozice X: ${userGroup.position.x.toFixed(1)}m`);
                }
                
                mapCenter.lat = Math.max(-85, Math.min(85, mapCenter.lat));
                mapCenter.lng = Math.max(-180, Math.min(180, mapCenter.lng));
                
                requestAnimationFrame(updateDesktopMovement);
            }
            updateDesktopMovement();
            
            // Mouse click
            renderer.domElement.addEventListener('click', onMapClick);
        }
        
        function onMapClick(event) {
            if (!raycaster) return;
            
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects([mapPlane]);
            
            if (intersects.length > 0) {
                const point = intersects[0].point;
                const gps = worldToGPSForCanvas(point);
                addMarker(gps.lat, gps.lng, `Desktop Marker ${markers.length + 1}`);
                updateGPSDisplay(gps.lat, gps.lng);
                updateStatus(`üìç Desktop marker: ${gps.lat.toFixed(4)}, ${gps.lng.toFixed(4)}`);
            }
        }
        
        // === MARKERY ===
        function addMarker(lat, lng, label, color = 0xff0000) {
            const worldPos = gpsToWorld(lat, lng);
            
            const geometry = new THREE.ConeGeometry(1, 3, 8);
            const material = new THREE.MeshBasicMaterial({ color: color });
            const marker = new THREE.Mesh(geometry, material);
            
            marker.position.set(worldPos.x, 1.5, worldPos.z);
            marker.userData = { label, lat, lng };
            marker.name = 'marker';
            
            mapGroup.add(marker);
            markers.push(marker);
            
            console.log(`üìç Marker p≈ôid√°n: ${label} na ${lat.toFixed(4)}, ${lng.toFixed(4)}`);
        }
        
        // === KOORDIN√ÅTY ===
        function gpsToWorld(lat, lng) {
            const scale = 50 / 180;
            const x = lng * scale;
            const z = -lat * scale;
            return { x, z };
        }
        
        function worldToGPS(worldPos) {
            const scale = 180 / 50;
            const lng = worldPos.x * scale;
            const lat = -worldPos.z * scale;
            return { lat, lng };
        }
        
        // === UTILITY FUNKCE ===
        function jumpTo(lat, lng) {
            mapCenter.lat = lat;
            mapCenter.lng = lng;
            loadCenterTile();
            updateStatus(`‚úàÔ∏è Skok na: ${lat.toFixed(3)}, ${lng.toFixed(3)}`);
        }
        
        function clearMarkers() {
            markers.forEach(marker => mapGroup.remove(marker));
            markers = [];
            updateStatus('üóëÔ∏è Markery smaz√°ny');
        }
        
        function updateGPSDisplay(lat = mapCenter.lat, lng = mapCenter.lng) {
            document.getElementById('coords').textContent = `GPS: ${lat.toFixed(3)}, ${lng.toFixed(3)}`;
        }
        
        function updateZoomDisplay() {
            document.getElementById('zoomInfo').textContent = `Zoom: ${mapZoom.toFixed(1)}`;
        }
        
        function updateStatus(message) {
            document.getElementById('status').textContent = message;
            console.log(message);
        }
        
        // === ANIMATION LOOP ===
        function animate() {
            updateVRInput();
            
            // Animace marker≈Ø
            markers.forEach((marker, i) => {
                marker.rotation.y += 0.02;
                marker.position.y = 1.5 + Math.sin(Date.now() * 0.003 + i) * 0.2;
            });
            
            updateGPSDisplay();
            updateZoomDisplay();
            
            renderer.render(scene, camera);
        }
        
        // === RESIZE ===
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        // === GLOB√ÅLN√ç FUNKCE ===
        window.jumpTo = jumpTo;
        window.clearMarkers = clearMarkers;
        
        // === START ===
        init();
        console.log('üó∫Ô∏è Jednoduch√° VR mapa p≈ôipravena bez import≈Ø!');
        
    </script>
</body>
</html>
