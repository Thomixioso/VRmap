<!DOCTYPE html>
<html lang="cs">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VR Placat√° Mapa - Meta Quest 3</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #000;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
        }
        
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            z-index: 100;
            background: rgba(0,0,0,0.8);
            padding: 15px;
            border-radius: 8px;
            max-width: 400px;
        }
        
        #vrButton {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 100;
        }
        
        #controls {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 100;
            background: rgba(0,0,0,0.8);
            padding: 15px;
            border-radius: 8px;
            color: white;
            min-width: 200px;
        }
        
        .back-button {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 101;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            text-decoration: none;
            padding: 12px 24px;
            border-radius: 25px;
            font-weight: 500;
            transition: all 0.3s ease;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .back-button:hover {
            background: rgba(255, 255, 255, 0.1);
            transform: translateX(-50%) translateY(-2px);
        }
        
        canvas {
            display: block;
        }
        
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 18px;
            text-align: center;
        }
        
        button {
            background: #4a90e2;
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            margin: 2px;
            font-size: 12px;
        }
        
        button:hover {
            background: #357abd;
        }
        
        input[type="range"] {
            width: 100%;
            margin: 5px 0;
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-button">‚Üê Zpƒõt na v√Ωbƒõr</a>
    
    <div id="info">
        <h3>üó∫Ô∏è VR Placat√° Mapa</h3>
        <p><strong>Desktop:</strong> WASD + my≈°, koleƒçko = zoom</p>
        <p><strong>VR:</strong> Ch≈Øze, teleport triggerem</p>
        <p><strong>Klik/Touch:</strong> P≈ôidat marker, zobrazit GPS</p>
        <div id="coords">GPS: 49.75, 15.5</div>
        <div id="status">Naƒç√≠t√°m mapu...</div>
    </div>
    
    <div id="controls">
        <h4>üéÆ Ovl√°d√°n√≠</h4>
        <div>
            <label>Zoom √∫rove≈à: <span id="zoomLevel">4</span></label>
            <input type="range" id="zoomSlider" min="3" max="8" value="4">
        </div>
        <div>
            <button onclick="moveToCenter()">üè† St≈ôed ƒåR</button>
            <button onclick="clearMarkers()">üóëÔ∏è Sma≈æ markery</button>
        </div>
        <div>
            <button onclick="toggleWireframe()">üìê Wireframe</button>
            <button onclick="toggleNight()">üåô Noƒçn√≠ re≈æim</button>
        </div>
    </div>
    
    <div class="loading" id="loading">üöÄ Naƒç√≠t√°m VR mapu...</div>
    <div id="vrButton"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script type="module">
        import { VRButton } from 'https://cdn.skypack.dev/three@0.128.0/examples/jsm/webxr/VRButton.js';
        import { XRControllerModelFactory } from 'https://cdn.skypack.dev/three@0.128.0/examples/jsm/webxr/XRControllerModelFactory.js';
        
        // === NASTAVEN√ç ===
        const WORLD_SIZE = 100; // velikost mapy v 3D prostoru
        const MAP_CENTER = { lat: 49.75, lng: 15.5 }; // st≈ôed ƒåR
        
        // === Z√ÅKLADN√ç SETUP ===
        let scene, camera, renderer, mapPlane, mapGroup;
        let controller1, controller2, controllerGrip1, controllerGrip2;
        let raycaster, mouse = new THREE.Vector2();
        let markers = [];
        let currentZoom = 4;
        let mapTextures = new Map();
        let isNightMode = false;
        let isWireframe = false;
        
        // === INICIALIZACE ===
        function init() {
            console.log('üöÄ Inicializuji VR placatou mapu...');
            
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB); // nebesky modr√°
            
            // Camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 10, 10); // nad mapou
            camera.lookAt(0, 0, 0);
            
            // Renderer s WebXR
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.xr.enabled = true;
            document.body.appendChild(renderer.domElement);
            
            // VR Button
            document.getElementById('vrButton').appendChild(VRButton.createButton(renderer));
            
            setupLighting();
            createFlatMap();
            setupVRControllers();
            setupInteractions();
            loadMapTiles();
            addSampleMarkers();
            
            // Animation loop
            renderer.setAnimationLoop(animate);
            
            document.getElementById('loading').style.display = 'none';
            updateStatus('‚úÖ VR mapa p≈ôipravena!');
        }
        
        // === OSVƒöTLEN√ç ===
        function setupLighting() {
            // Ambientn√≠ svƒõtlo pro den
            const ambientLight = new THREE.AmbientLight(0x404040, 0.8);
            scene.add(ambientLight);
            
            // Slunce
            const sunLight = new THREE.DirectionalLight(0xffffff, 1.2);
            sunLight.position.set(50, 100, 50);
            sunLight.castShadow = true;
            sunLight.shadow.mapSize.width = 2048;
            sunLight.shadow.mapSize.height = 2048;
            sunLight.shadow.camera.near = 0.5;
            sunLight.shadow.camera.far = 500;
            sunLight.shadow.camera.left = -100;
            sunLight.shadow.camera.right = 100;
            sunLight.shadow.camera.top = 100;
            sunLight.shadow.camera.bottom = -100;
            scene.add(sunLight);
            
            // Mlha pro vzd√°lenost
            scene.fog = new THREE.Fog(0x87CEEB, 50, 200);
        }
        
        // === PLACAT√Å MAPA ===
        function createFlatMap() {
            console.log('üó∫Ô∏è Vytv√°≈ô√≠m placatou mapu...');
            
            mapGroup = new THREE.Group();
            scene.add(mapGroup);
            
            // Z√°kladn√≠ rovina
            const geometry = new THREE.PlaneGeometry(WORLD_SIZE, WORLD_SIZE, 100, 100);
            
            // Materi√°l s texturou
            const material = new THREE.MeshLambertMaterial({
                color: 0x90EE90, // z√°kladn√≠ zelen√°
                wireframe: false
            });
            
            mapPlane = new THREE.Mesh(geometry, material);
            mapPlane.rotation.x = -Math.PI / 2; // polo≈æit na zem
            mapPlane.receiveShadow = true;
            mapPlane.name = 'mapPlane';
            
            mapGroup.add(mapPlane);
            
            // Okraje mapy
            createMapBorders();
        }
        
        function createMapBorders() {
            const borderHeight = 2;
            const borderGeometry = new THREE.BoxGeometry(2, borderHeight, WORLD_SIZE + 4);
            const borderMaterial = new THREE.MeshLambertMaterial({ color: 0x654321 });
            
            // 4 strany
            const borders = [
                { x: -WORLD_SIZE/2 - 1, z: 0 }, // lev√°
                { x: WORLD_SIZE/2 + 1, z: 0 },  // prav√°
                { x: 0, z: -WORLD_SIZE/2 - 1 }, // zadn√≠
                { x: 0, z: WORLD_SIZE/2 + 1 }   // p≈ôedn√≠
            ];
            
            borders.forEach((pos, i) => {
                const border = new THREE.Mesh(
                    i < 2 ? borderGeometry : new THREE.BoxGeometry(WORLD_SIZE + 4, borderHeight, 2),
                    borderMaterial
                );
                border.position.set(pos.x, borderHeight/2, pos.z);
                border.castShadow = true;
                mapGroup.add(border);
            });
        }
        
        // === NAƒå√çT√ÅN√ç MAP TILES ===
        function loadMapTiles() {
            updateStatus('üì° Naƒç√≠t√°m map tiles...');
            
            // Pro demonstraci - vytvo≈ô√≠me procedur√°ln√≠ texturu
            // V re√°ln√© aplikaci byste naƒç√≠tali z tiles_satellite_labeled/{z}/{x}/{y}.jpg
            createProceduralMapTexture();
        }
        
        function createProceduralMapTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 2048;
            canvas.height = 2048;
            const ctx = canvas.getContext('2d');
            
            // Z√°kladn√≠ podklad - tr√°vn√≠k
            const gradient = ctx.createRadialGradient(1024, 1024, 0, 1024, 1024, 1024);
            gradient.addColorStop(0, '#90EE90');
            gradient.addColorStop(0.5, '#228B22');
            gradient.addColorStop(1, '#006400');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 2048, 2048);
            
            // Simulace mƒõst a silnic
            ctx.strokeStyle = '#A0A0A0';
            ctx.lineWidth = 3;
            drawRandomRoads(ctx);
            
            // Mƒõsta
            ctx.fillStyle = '#FF6B6B';
            drawCity(ctx, 1024, 800, 'Praha'); // Praha p≈ôibli≈ænƒõ uprost≈ôed
            drawCity(ctx, 1200, 1100, 'Brno');
            drawCity(ctx, 800, 900, 'Plze≈à');
            drawCity(ctx, 1400, 700, 'Ostrava');
            
            // Aplikuj texturu na mapu
            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            
            mapPlane.material.map = texture;
            mapPlane.material.needsUpdate = true;
            
            updateStatus('‚úÖ Mapa naƒçtena');
        }
        
        function drawRandomRoads(ctx) {
            for (let i = 0; i < 20; i++) {
                ctx.beginPath();
                const startX = Math.random() * 2048;
                const startY = Math.random() * 2048;
                ctx.moveTo(startX, startY);
                
                for (let j = 0; j < 5; j++) {
                    const endX = startX + (Math.random() - 0.5) * 400;
                    const endY = startY + (Math.random() - 0.5) * 400;
                    ctx.lineTo(endX, endY);
                }
                ctx.stroke();
            }
        }
        
        function drawCity(ctx, x, y, name) {
            // Mƒõsto jako kruh
            ctx.beginPath();
            ctx.arc(x, y, 20, 0, 2 * Math.PI);
            ctx.fill();
            
            // N√°zev mƒõsta
            ctx.fillStyle = '#FFFFFF';
            ctx.font = '24px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(name, x, y - 30);
            ctx.fillStyle = '#FF6B6B'; // reset barvy
        }
        
        // === VR OVLADAƒåE ===
        function setupVRControllers() {
            console.log('üéÆ Nastavuji VR ovladaƒçe...');
            
            const controllerModelFactory = new XRControllerModelFactory();
            raycaster = new THREE.Raycaster();
            
            // Controller 1 (prav√Ω)
            controller1 = renderer.xr.getController(0);
            controller1.addEventListener('selectstart', onSelectStart);
            controller1.addEventListener('selectend', onSelectEnd);
            scene.add(controller1);
            
            controllerGrip1 = renderer.xr.getControllerGrip(0);
            controllerGrip1.add(controllerModelFactory.createControllerModel(controllerGrip1));
            scene.add(controllerGrip1);
            
            // Controller 2 (lev√Ω)
            controller2 = renderer.xr.getController(1);
            controller2.addEventListener('selectstart', onSelectStart);
            controller2.addEventListener('selectend', onSelectEnd);
            scene.add(controller2);
            
            controllerGrip2 = renderer.xr.getControllerGrip(1);
            controllerGrip2.add(controllerModelFactory.createControllerModel(controllerGrip2));
            scene.add(controllerGrip2);
            
            // Paprsek z ovladaƒçe
            const geometry = new THREE.BufferGeometry().setFromPoints([
                new THREE.Vector3(0, 0, 0),
                new THREE.Vector3(0, 0, -1)
            ]);
            
            const line = new THREE.Line(geometry, new THREE.LineBasicMaterial({ color: 0xff0000 }));
            line.name = 'line';
            line.scale.z = 10;
            
            controller1.add(line.clone());
            controller2.add(line.clone());
        }
        
        // === INTERAKCE ===
        function setupInteractions() {
            // Desktop controls
            setupDesktopControls();
            
            // Mouse/touch pro klik√°n√≠
            renderer.domElement.addEventListener('click', onMapClick);
            
            // Zoom slider
            document.getElementById('zoomSlider').addEventListener('input', (e) => {
                currentZoom = parseInt(e.target.value);
                document.getElementById('zoomLevel').textContent = currentZoom;
                updateMapScale();
            });
        }
        
        function setupDesktopControls() {
            const keys = { w: false, a: false, s: false, d: false };
            
            document.addEventListener('keydown', (e) => {
                const key = e.key.toLowerCase();
                if (keys.hasOwnProperty(key)) keys[key] = true;
            });
            
            document.addEventListener('keyup', (e) => {
                const key = e.key.toLowerCase();
                if (keys.hasOwnProperty(key)) keys[key] = false;
            });
            
            // Pohyb kamery
            function updateMovement() {
                const speed = 0.5;
                if (keys.w) camera.position.z -= speed;
                if (keys.s) camera.position.z += speed;
                if (keys.a) camera.position.x -= speed;
                if (keys.d) camera.position.x += speed;
                
                requestAnimationFrame(updateMovement);
            }
            updateMovement();
            
            // Mouse look
            let isMouseDown = false;
            renderer.domElement.addEventListener('mousedown', () => isMouseDown = true);
            renderer.domElement.addEventListener('mouseup', () => isMouseDown = false);
            
            renderer.domElement.addEventListener('mousemove', (e) => {
                if (!isMouseDown) return;
                
                const deltaX = e.movementX * 0.002;
                const deltaY = e.movementY * 0.002;
                
                camera.rotation.y -= deltaX;
                camera.rotation.x -= deltaY;
                camera.rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, camera.rotation.x));
            });
            
            // Zoom koleƒçkem
            renderer.domElement.addEventListener('wheel', (e) => {
                camera.position.y += e.deltaY * 0.01;
                camera.position.y = Math.max(2, Math.min(50, camera.position.y));
            });
        }
        
        // === VR EVENTS ===
        function onSelectStart(event) {
            const controller = event.target;
            const intersections = getIntersections(controller);
            
            if (intersections.length > 0) {
                const intersection = intersections[0];
                
                if (intersection.object.name === 'mapPlane') {
                    // P≈ôidat marker na m√≠sto
                    const worldPos = intersection.point;
                    const gps = worldToGPS(worldPos);
                    addMarker(gps.lat, gps.lng, `Marker ${markers.length + 1}`);
                    
                    // Haptic feedback
                    if (controller.gamepad && controller.gamepad.hapticActuators) {
                        controller.gamepad.hapticActuators[0].pulse(0.5, 100);
                    }
                    
                    updateGPSDisplay(gps.lat, gps.lng);
                    updateStatus(`üìç Marker p≈ôid√°n: ${gps.lat.toFixed(4)}, ${gps.lng.toFixed(4)}`);
                }
            }
        }
        
        function onSelectEnd(event) {
            // End selection
        }
        
        function getIntersections(controller) {
            const tempMatrix = new THREE.Matrix4();
            tempMatrix.identity().extractRotation(controller.matrixWorld);
            
            raycaster.ray.origin.setFromMatrixPosition(controller.matrixWorld);
            raycaster.ray.direction.set(0, 0, -1).applyMatrix4(tempMatrix);
            
            return raycaster.intersectObjects([mapPlane, ...markers]);
        }
        
        function onMapClick(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects([mapPlane]);
            
            if (intersects.length > 0) {
                const worldPos = intersects[0].point;
                const gps = worldToGPS(worldPos);
                addMarker(gps.lat, gps.lng, `Marker ${markers.length + 1}`);
                updateGPSDisplay(gps.lat, gps.lng);
                updateStatus(`üìç Marker p≈ôid√°n: ${gps.lat.toFixed(4)}, ${gps.lng.toFixed(4)}`);
            }
        }
        
        // === MARKERY ===
        function addMarker(lat, lng, label, color = 0xff0000) {
            const worldPos = gpsToWorld(lat, lng);
            
            // Marker geometrie
            const geometry = new THREE.ConeGeometry(1, 3, 8);
            const material = new THREE.MeshLambertMaterial({ color: color });
            const marker = new THREE.Mesh(geometry, material);
            
            marker.position.set(worldPos.x, 1.5, worldPos.z);
            marker.castShadow = true;
            marker.userData = { label, lat, lng };
            
            scene.add(marker);
            markers.push(marker);
            
            // Text label
            createTextLabel(marker, label);
            
            console.log(`üìç Marker "${label}" p≈ôid√°n na: ${lat.toFixed(4)}, ${lng.toFixed(4)}`);
        }
        
        function createTextLabel(marker, text) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 256;
            canvas.height = 64;
            
            ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
            ctx.fillRect(0, 0, 256, 64);
            
            ctx.fillStyle = 'white';
            ctx.font = '24px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(text, 128, 40);
            
            const texture = new THREE.CanvasTexture(canvas);
            const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
            const sprite = new THREE.Sprite(spriteMaterial);
            
            sprite.position.set(0, 3, 0);
            sprite.scale.set(4, 1, 1);
            
            marker.add(sprite);
        }
        
        function addSampleMarkers() {
            const sampleLocations = [
                {name: "Praha", lat: 50.0755, lng: 14.4378, color: 0xff0000},
                {name: "Brno", lat: 49.1951, lng: 16.6068, color: 0x00ff00},
                {name: "Plze≈à", lat: 49.7384, lng: 13.3736, color: 0x0000ff},
                {name: "Ostrava", lat: 49.8175, lng: 18.2625, color: 0xffff00}
            ];
            
            sampleLocations.forEach(location => {
                addMarker(location.lat, location.lng, location.name, location.color);
            });
        }
        
        // === KOORDIN√ÅTY ===
        function gpsToWorld(lat, lng) {
            // P≈ôevod GPS na world pozici (zjednodu≈°en√©)
            const x = (lng - MAP_CENTER.lng) * WORLD_SIZE / 10; // ~10¬∞ lng = world_size
            const z = -(lat - MAP_CENTER.lat) * WORLD_SIZE / 10; // z√°porn√© Z pro spr√°vnou orientaci
            return { x, z };
        }
        
        function worldToGPS(worldPos) {
            const lng = MAP_CENTER.lng + (worldPos.x * 10 / WORLD_SIZE);
            const lat = MAP_CENTER.lat - (worldPos.z * 10 / WORLD_SIZE);
            return { lat, lng };
        }
        
        // === UTILITY FUNKCE ===
        function updateMapScale() {
            const scale = Math.pow(2, currentZoom - 4); // exponenci√°ln√≠ ≈°k√°lov√°n√≠
            mapGroup.scale.setScalar(scale);
        }
        
        function moveToCenter() {
            camera.position.set(0, 10, 10);
            camera.lookAt(0, 0, 0);
            updateStatus('üè† N√°vrat do st≈ôedu');
        }
        
        function clearMarkers() {
            markers.forEach(marker => scene.remove(marker));
            markers = [];
            updateStatus('üóëÔ∏è V≈°echny markery smaz√°ny');
        }
        
        function toggleWireframe() {
            isWireframe = !isWireframe;
            mapPlane.material.wireframe = isWireframe;
            updateStatus(`üìê Wireframe: ${isWireframe ? 'ZAP' : 'VYP'}`);
        }
        
        function toggleNight() {
            isNightMode = !isNightMode;
            scene.background = new THREE.Color(isNightMode ? 0x000033 : 0x87CEEB);
            updateStatus(`üåô Noƒçn√≠ re≈æim: ${isNightMode ? 'ZAP' : 'VYP'}`);
        }
        
        function updateGPSDisplay(lat = MAP_CENTER.lat, lng = MAP_CENTER.lng) {
            document.getElementById('coords').textContent = `GPS: ${lat.toFixed(4)}, ${lng.toFixed(4)}`;
        }
        
        function updateStatus(message) {
            document.getElementById('status').textContent = message;
            console.log(message);
        }
        
        // === ANIMATION LOOP ===
        function animate() {
            // Animace marker≈Ø - lehk√© kol√©b√°n√≠
            markers.forEach((marker, i) => {
                marker.rotation.y += 0.01;
                marker.position.y = 1.5 + Math.sin(Date.now() * 0.002 + i) * 0.1;
            });
            
            renderer.render(scene, camera);
        }
        
        // === RESIZE ===
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        // === GLOB√ÅLN√ç FUNKCE PRO TLAƒå√çTKA ===
        window.moveToCenter = moveToCenter;
        window.clearMarkers = clearMarkers;
        window.toggleWireframe = toggleWireframe;
        window.toggleNight = toggleNight;
        
        // === START ===
        init();
        
        console.log('üó∫Ô∏è VR placat√° mapa p≈ôipravena!');
        
    </script>
</body>
</html>
